<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>HashMap原理解析</title>
      <link href="/posts/HashMap_Analysis.html"/>
      <url>/posts/HashMap_Analysis.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>HashMap 是我们使用频率最高的集合之一。它是用于映射(键值对)处理的数据类型。随着 JDK 版本的更新，JDK1.8 对 HashMap 底层的实现进行了优化，例如引入红黑树的数据结构。</p><p>本文将深入探讨 HashMap 的结构实现和功能原理。</p><h2 id="基本特点"><a href="#基本特点" class="headerlink" title="基本特点"></a>基本特点</h2><p>HashMap 你应该也很熟悉。我在这就简单说一下它的基本特点，</p><ul><li>HashMap是基于哈希表的 Map 接口的实现。</li><li>允许 null 键和 null 值，最多只允许一条记录的键为 null，允许多条记录的值为 null。</li><li>不保证映射的顺序。特别是，<strong>它不能保证顺序会随着时间的推移保持恒定</strong>。</li><li>HashMap 根据键的 hashCode 值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度 O(1)。</li></ul><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>从结构实现来讲，HashMap 是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的。</p><p><img src="../img/hashmap/map_data_structure.png" alt=""></p><h3 id="HashMap-数据底层具体存储的是什么？"><a href="#HashMap-数据底层具体存储的是什么？" class="headerlink" title="HashMap 数据底层具体存储的是什么？"></a>HashMap 数据底层具体存储的是什么？</h3><p>通过查看 HashMap 的源码，它其中有一个非常重要的字段 <code>Node&lt;K,V&gt;[] table</code>，即哈希桶数组，是一个Node 的数组。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;<span class="comment">// 用来定位数组索引位置</span></span><br><span class="line">        <span class="keyword">final</span> K key; <span class="comment">// 用来存储的 key</span></span><br><span class="line">        V value; <span class="comment">// 存储的 value</span></span><br><span class="line">        Node&lt;K,V&gt; next;<span class="comment">// 链表的下一个元素</span></span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123;...&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123;...&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;...&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Node 是 HashMap 中的一个内部类，实现了 Map.Entry 接口，本质是就是一个映射(键值对)。</p><p>我们在 HashMap 中存储的每一个值，都是一个 Node。</p><h3 id="Map-为什么要用数组-单链表的方式？"><a href="#Map-为什么要用数组-单链表的方式？" class="headerlink" title="Map 为什么要用数组+单链表的方式？"></a>Map 为什么要用数组+单链表的方式？</h3><p>任何哈希函数基本都无法彻底避免碰撞，常见的解决碰撞的方法有以下几种：</p><ul><li><p>开放寻址法：如果出现了散列冲突，就重新探测一个空闲位置，将其插入。</p></li><li><p>链表法：就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被 Hash 后，得到数组下标，把数据放在对应下标元素的链表上。</p></li><li><p>再哈希法：当哈希地址发生冲突用其他的函数计算另一个哈希函数地址，直到冲突不再产生为止。</p></li><li><p>建立公共溢出区：将哈希表分为基本表和溢出表两部分，发生冲突的元素都放入溢出表中。</p></li></ul><p>HashMap 采用的就是<strong>链表法</strong>这种方式。 但即使负载因子和 Hash 算法设计的再合理，也免不了会出现拉链过长的情况，<strong>一旦出现拉链过长，则会严重影响 HashMap 的性能。</strong></p><p>于是，在 JDK1.8 版本中，HashMap 做了进一步的优化，引入了红黑树。当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高 HashMap 的性能。</p><h4 id="为什么转成红黑树就能提高性能呢？"><a href="#为什么转成红黑树就能提高性能呢？" class="headerlink" title="为什么转成红黑树就能提高性能呢？"></a>为什么转成红黑树就能提高性能呢？</h4><p>虽然链表的删除和插入的速度很快，但是查找的速度很慢，需要从头遍历整个链表，时间复杂度为 O(n)，删除和插入的前提是<strong>首先要找到整个元素</strong>，因此也会受到链表长度的影响。当链表过长时，增删改查速度就会降低。</p><p>红黑树是一种平衡二叉树，它的增删改查的时间复杂度是 O(logn)。</p><h2 id="HashMap-的成员变量"><a href="#HashMap-的成员变量" class="headerlink" title="HashMap 的成员变量"></a>HashMap 的成员变量</h2><p>HashMap 中的成员变量，除了一些常量外，主要有以下几个。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> size; <span class="comment">// 集合大小</span></span><br><span class="line"><span class="keyword">int</span> modCount; <span class="comment">// 内部发生变化的次数</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor; <span class="comment">// 负载因子</span></span><br><span class="line"><span class="keyword">int</span> threshold; <span class="comment">// 阈值</span></span><br></pre></td></tr></table></figure><p>size 比较简单，就是 HashMap 中包含的映射的总数。</p><p>modCount，主要用来记录 HashMap 内部结构发生变化的次数，主要用于迭代的快速失败。强调一点，<strong>内部结构发生变化指的是结构发生变化</strong>，例如 put 新键值对，但是某个 key 对应的 value 值被覆盖不属于结构变化。</p><p>loadFactor 负载因子，默认值是0.75，负载因子越大，说明 Map 中的元素越多，空闲位置越少，散列冲突的概率就越大。</p><p>threshold 阈值，是 HashMap 所能容纳的最大数据量的 Node (键值对)个数。</p><p>算法公式为：<code>threshold = length * loadFactor</code>。其中 length 是 Node[] table 的长度(默认 16)。</p><p>threshold 就是在此 loadFactor 和 length 对应下允许的最大元素数目，超过这个数目就重新 resize (扩容)，扩容后的 HashMap 容量是之前容量的两倍。</p><h2 id="确定数组索引位置的-hash-算法"><a href="#确定数组索引位置的-hash-算法" class="headerlink" title="确定数组索引位置的 hash 算法"></a>确定数组索引位置的 hash 算法</h2><p>不管是添加、删除还是查找，<strong>第一步首先是要确定当前元素在 HashMap 中的位置。</strong></p><p>HashMap 中的 hash 采用的是<strong>取 key 的 hashCode 值，然后进行高位运算，再进行取模运算。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> h;</span><br><span class="line">      <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="为什么要采用这种算法呢？"><a href="#为什么要采用这种算法呢？" class="headerlink" title="为什么要采用这种算法呢？"></a>为什么要采用这种算法呢？</h3><p>我们知道，在 HashMap 中采用 hash 为 key，因此我们要尽量避免 hash 碰撞。</p><p>上面的代码中，<code>key.hashCode()</code>函数调用的是 key 键值类型自带的哈希函数，返回 int 型的值。</p><p>int 值的取值范围在 <code>-2^31 ~ 2^31 - 1</code> 之间，大约有 40 亿的空间，如果直接拿散列表的值做数组的所含，虽然很难出现碰撞，但是 40 亿的长度实在是太大了，不太现实。</p><p>因此需要对得到的散列值进行进一步的操作处理。</p><p>java 8 采用 key.hashCode() 与 hash 值的高 16 位进行异或运算。</p><blockquote><p>异或：如果a、b两个值不相同，则异或结果为1。 如果a、b两个值相同，异或结果为0。</p></blockquote><p>为什么这里需要将高位数据移位到低位进行异或运算呢？</p><p>这是因为有些数据计算出的哈希值差异<strong>主要在高位</strong>，利用高半区和低半区做异或，就是为了<strong>混合原始哈希码的高位和低位，以此来加大低位的随机性</strong>。混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来，可以有效避免类似情况下的哈希碰撞。</p><p><img src="../img/hashmap/jisuan_hash.png" alt=""></p><h2 id="存储数据的-put-方法"><a href="#存储数据的-put-方法" class="headerlink" title="存储数据的 put 方法"></a>存储数据的 put 方法</h2><p>HashMap 的 put 方法主要分为以下几步：</p><p>①. 判断键值对数组 table[i] 是否为空或为 null，否则执行 resize() 进行扩容；</p><p>②. 根据键值 key 计算 hash 值得到插入的数组索引 i，如果 table[i]==null，直接新建节点添加，转向 ⑥，如果 table[i] 不为空，转向③；</p><p>③. 判断 table[i] 的首个元素是否和 key 一样，如果相同直接覆盖 value，否则转向④，这里的相同指的是 hashCode 以及 equals；</p><p>④. 判断 table[i] 是否为 TreeNode，即 table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；</p><p>⑤. 遍历 table[i]，判断链表长度是否大于 8，大于 8 的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现 key 已经存在直接覆盖 value 即可；</p><p>⑥. 插入成功后，判断实际存在的键值对数量 size 是否超多了最大容量 threshold，如果超过，进行扩容。</p><p>JDK1.8HashMap的put方法源码如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对key的hashCode()做hash</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K, V&gt;[] tab;</span><br><span class="line">    Node&lt;K, V&gt; p;</span><br><span class="line">    <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 步骤①：tab为空则创建</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 步骤②：计算index，并对null做处理 </span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K, V&gt; e;</span><br><span class="line">        K k;</span><br><span class="line">        <span class="comment">// 步骤③：节点key存在，直接覆盖value</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">            <span class="comment">// 步骤④：判断该链为红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K, V&gt;) p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="comment">// 步骤⑤：该链为链表</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    链表长度大于<span class="number">8</span>转换为红黑树进行处理</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st  </span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                key已经存在直接覆盖value</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 步骤⑥：超过最大容量 就扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 put 时，会通过 <code>(n-1) &amp; hash</code> 来计算当前元素的坐标索引。</p><hr><h4 id="番外：-为什么用-amp-操作呢？"><a href="#番外：-为什么用-amp-操作呢？" class="headerlink" title="番外： 为什么用 &amp; 操作呢？"></a>番外： 为什么用 &amp; 操作呢？</h4><p>主要是用来取模。</p><p><strong>位运算（&amp;）效率要比取模运算（%）高很多，主要原因是位运算直接对内存数据进行操作，不需要转成十进制，因此处理速度非常快。</strong></p><h4 id="为什么可以使用位运算-amp-来实现取模运算-呢"><a href="#为什么可以使用位运算-amp-来实现取模运算-呢" class="headerlink" title="为什么可以使用位运算(&amp;)来实现取模运算(%)呢"></a>为什么可以使用位运算(&amp;)来实现取模运算(%)呢</h4><p>原理如下：</p><blockquote><p>X % 2^n = X &amp; (2^n – 1)</p><p>2^n 表示 2 的 n 次方，也就是说，一个数对 2^n 取模 == 一个数和 (2^n – 1) 做按位与运算 。</p><p>假设 n 为3，则 2^3 = 8，表示成 2 进制就是 1000。2^3 -1 = 7 ，即 0111。</p><p>此时 X &amp; (2^3 – 1) 就相当于取 X 的 2 进制的最后三位数。</p><p>从 2 进制角度来看，X / 8相当于 X &gt;&gt; 3，即把 X 右移 3 位，此时得到了 X / 8 的商，而被移掉的部分(后三位)，则是X % 8，也就是余数。</p></blockquote><p>简单来讲就是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 % 8 &#x3D; 6 ，6 &amp; 7 &#x3D; 6；</span><br><span class="line">10 &amp; 8 &#x3D; 2 ，10 &amp; 7 &#x3D; 2</span><br></pre></td></tr></table></figure><p>记住会用就行。</p><hr><p>具体的 put 过程可以参照下图进行理解。</p><p><img src="../img/hashmap/hashmap_put.png" alt="HashMap 的 put 流程"></p><h2 id="HashMap-的扩容机制"><a href="#HashMap-的扩容机制" class="headerlink" title="HashMap 的扩容机制"></a>HashMap 的扩容机制</h2><p>扩容(resize)就是重新计算容量。</p><p>当我们不停的向 HashMap 中添加元素，当达到临界值，HashMap 无法添加新元素时，就需要进行扩容，以便能装入更多的元素。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table; <span class="comment">// 新建变量扩容前的 Entry Node</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length; <span class="comment">//扩容前数组的长度</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold; <span class="comment">// 扩容前能容纳最大键值对数量</span></span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123; </span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                  oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的 resize 上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 将之前的元素都移动到新的 buckets 中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 暂时忽略红黑树部分</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 链表优化重 hash 的代码块</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                         <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;  <span class="comment">//仅仅是判断元素是否需要换位置，不要理解为元素的新位置</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                     <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在经过 resize 扩容后，数组的长度会扩大为原来的 2 倍，所以，<strong>元素的位置要么是在原位置，要么是在原位置再移动 2 次幂的位置</strong>。</p><p>结合下图理解，n 为 table 的长度，图（a）表示扩容前的 key1 和 key2 两种 key 确定索引位置的示例，图（b）表示扩容后 key1 和 key2 两种 key 确定索引位置的示例，其中 hash1 是 key1 对应的哈希与高位运算结果。</p><p><img src="../img/resize_hash1.png" alt=""></p><p>元素在重新计算 hash 之后，因为 n 变为 2 倍，那么 n-1 的范围在高位多 1bit(红色)，因此新的 index 就会发生这样的变化。</p><p><img src="../img/hashmap/element_index_change.png" alt="元素位置的变化"></p><p>因此，扩容时，只需要看看原来的 hash 值新增的那个 bit 是 1 还是 0 就行了，是 0 的话索引没变，是 1 的话索引变成“原索引 + oldCap”，可以结合下图理解，下图是 16 -&gt; 32 的过程。</p><p><img src="../img/hashmap/resize_syt.png" alt="扩容示意图"></p><p>这个设计确实非常的巧妙，既省去了重新计算 hash 值的时间，而且同时，由于新增的 1bit 是 0 还是 1 可以认为是随机的，因此 resize 的过程，均匀的把之前的冲突的节点分散到新的 bucket 了。</p><p>HashMap 的 get 方法比较简单，在这里就不再进行分析了。</p><h2 id="为什么HashMap线程不安全"><a href="#为什么HashMap线程不安全" class="headerlink" title="为什么HashMap线程不安全?"></a>为什么HashMap线程不安全?</h2><p>1.多线程 put，导致的数据不一致。</p><p>当拥有多个线程时，每个线程都会去抢占 CPU 资源，而 CPU 根据一定的线程调度算法来切换线程，因此就可能出现线程 A 没执行完毕，线程 B 就拿到 CPU 资源去执行了，从而会导致数据错乱。</p><p>比如有两个线程 A 和 B。</p><p>A 希望插入一个 key-value 到 HashMap 中，在完成了计算索引坐标，获取链表头结点的操作后，线程 A 的时间用完了；</p><p>B 开始执行，B 计算完毕，成功将记录插入到了 HashMap 中；</p><p>此时，A 再次被执行，假设 A、B 计算出的索引是一致的，由于 A 不知道 B 已经插入到此节点了，因此 A 进行插入事，就会覆盖 B 的记录，就造成了数据不一致的行为。</p><p>2.resize 造成的无限循环</p><p>HashMap 在 resize 时，会重新计算元素的位置与 hash。</p><p>因此在多线程操作 HashMap 时，可能会出现node 的 next 指向的下一个元素之间，形成环形链表，导致无限循环。</p><p><img src="../img/hashmap/hashmap_dead_loop.png" alt="image"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://tech.meituan.com/2016/06/24/java-hashmap.html" target="_blank" rel="noopener">https://tech.meituan.com/2016/06/24/java-hashmap.html</a></li><li><a href="https://www.hollischuang.com/archives/2091" target="_blank" rel="noopener">https://www.hollischuang.com/archives/2091</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 协议完全解析</title>
      <link href="/posts/http_analysis.html"/>
      <url>/posts/http_analysis.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>HTTP 的全称是 HyperText Transfer Protocol (超文本传输协议)的缩写，是一种建立在 TCP 上的无状态连接。HTTP 是互联网的<strong>基础协议</strong>，用于客户端与服务器之间的通信，它规定了客户端和服务器之间的<strong>通信格式</strong>，包括请求与响应的格式。<br> <a id="more"></a></p><p>基本的工作流程是客户端发送一个 HTTP 请求，服务端收到请求开始处理，处理结束返回给客户端结果，客户端对结果进行处理并展示。</p><p>现在最流行的 HTTP 版本还是 1997 年发布的 HTTP/1.1。<br><img src="https://ww1.sinaimg.cn/large/007i4MEmgy1fyuos2jbzvj30fb051t90.jpg" alt=""></p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>HTTP 的工作方式</li><li>HTTP 的报文格式</li><li>HTTP 起始行</li><li>HTTP 请求方法</li><li>HTTP 响应码</li><li>HTTP Headers<h2 id="一、-HTTP-的工作方式"><a href="#一、-HTTP-的工作方式" class="headerlink" title="一、 HTTP 的工作方式"></a>一、 HTTP 的工作方式</h2><h3 id="1-1-请求过程"><a href="#1-1-请求过程" class="headerlink" title="1.1 请求过程"></a>1.1 请求过程</h3>客户端向服务端发送一段请求报文，服务端收到后，返回响应报文，客户端对响应内容进行展示。</li></ul><img src = "https://ww1.sinaimg.cn/large/007i4MEmgy1fyvp5x2xupj317g0nmdjm.jpg" width = 80%/><p>一个 HTTP 的请求必定是<strong>由客户端发起，服务器端回复响应</strong>。服务器在没有接收到请求之前不会发送响应。</p><blockquote><p>名词解释</p><p>客户端：请求访问文本或图像等资源的一端。</p><p>服务端：提供资源响应的一端。</p><p>资源：网络上的一切内容都是资源，无论是图片文字还是动态代码。</p></blockquote><h3 id="1-2-请求方式"><a href="#1-2-请求方式" class="headerlink" title="1.2 请求方式"></a>1.2 请求方式</h3><h4 id="web-浏览器请求："><a href="#web-浏览器请求：" class="headerlink" title="web 浏览器请求："></a>web 浏览器请求：</h4><img src="https://ww1.sinaimg.cn/large/007i4MEmgy1fyvq039dv9j30gt048gn8.jpg" width = 20% height = 20% /><p>请求过程如下 ⬇️</p><ol><li>用户输入地址后回车或点击链接</li><li>浏览器拼装 HTTP 报文并发送请求给服务器 </li><li>服务器处理请求后，发送响应报文给浏览器 </li><li>浏览器解析响应报文并使用渲染引擎显示到界面</li></ol><h4 id="APP-客户端请求："><a href="#APP-客户端请求：" class="headerlink" title="APP 客户端请求："></a>APP 客户端请求：</h4><img src="https://ww1.sinaimg.cn/large/007i4MEmgy1fyvq1pw7d9j30u009utas.jpg" width = 40% height = 40% /><p>请求过程如下 ⬇️</p><ol><li>用户点击或界面自动触发联网需求</li><li>Android 代码调用拼装 HTTP 报文并发送请求到服务器</li><li>服务器处理请求后发送响应报文给手机</li><li>Android 代码处理响应报文并作出相应处理(如储存数据、加工数据、显示数据到界面)</li></ol><h3 id="1-3-报文是什么"><a href="#1-3-报文是什么" class="headerlink" title="1.3 报文是什么"></a>1.3 报文是什么</h3><p>报文是在 HTTP 应用程序之间发送的<strong>数据块</strong>。这些数据块以一些文本的元信息 (meta 标签中的信息) 开头，描述了报文的内容及含义。</p><p>每条报文都包含<strong>一条来自于客户端的请求，或者一条来自于服务端的响应</strong>。</p><p>它由 3 部分组成：对报文进行描述的「<strong>起始行</strong>」、包含属性的「<strong>首部(Header)</strong>」以及可选的、包含数据的「<strong>主体(body)</strong>」</p><p><img src="https://ww1.sinaimg.cn/large/007i4MEmgy1fz1ph978fpj30nh0anwfy.jpg" alt=""></p><h2 id="二、HTTP-的报文格式"><a href="#二、HTTP-的报文格式" class="headerlink" title="二、HTTP 的报文格式"></a>二、HTTP 的报文格式</h2><h3 id="2-1-请求报文的格式"><a href="#2-1-请求报文的格式" class="headerlink" title="2.1 请求报文的格式"></a>2.1 请求报文的格式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;method&gt; &lt;path&gt; &lt;HTTP version&gt;</span><br><span class="line">&lt;headers&gt;</span><br><span class="line"></span><br><span class="line">&lt;entity-body&gt;</span><br></pre></td></tr></table></figure><h3 id="2-2-响应报文的格式"><a href="#2-2-响应报文的格式" class="headerlink" title="2.2 响应报文的格式"></a>2.2 响应报文的格式</h3><p>(注意，<strong>只有起始行的语法与请求报文有所不同</strong>)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;HTTP version&gt; &lt;status code&gt; &lt;reason-phrase&gt;</span><br><span class="line">&lt;headers&gt;</span><br><span class="line"></span><br><span class="line">&lt;entity-body&gt;</span><br></pre></td></tr></table></figure><p>下面是对各部分的简要描述，后面会详细介绍。</p><ul><li>方法 (method)<br>客户端希望服务器对资源执行的动作，常见的方法有 Get、Post、HEAD 等。</li><li>请求路径 (path)<br>请求的 URL 描述了要对哪个资源执行这个方法，是给服务器看的。</li><li>HTTP 版本(HTTP version)  </li><li>状态码(status code)<br>不同状态码对应不同的响应状态</li><li>原因短句(reason-phrase)<br>对状态码进行简单的描述。</li><li>首部(headers)<br>包含许多键值对，是对响应数据的一些格式信息。</li></ul><h2 id="三、-Method-请求方法"><a href="#三、-Method-请求方法" class="headerlink" title="三、 Method(请求方法)"></a>三、 Method(请求方法)</h2><p>最常见的请求方法就是 <code>GET</code> 和 <code>POST</code>了。除此之外还有 <code>PUT</code>、<code>DELETE</code>、<code>HEAD</code> 等。</p><h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><ul><li>最常见的请求方式</li><li>指定请求路径，向服务器请求资源</li><li>只获取资源，不对服务器数据进行修改</li><li>不发送 body</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET  &#x2F;users&#x2F;1  HTTP&#x2F;1.1</span><br><span class="line">Host: api.github.com</span><br></pre></td></tr></table></figure><p>对应的 Retrofit 的代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GET(&quot;&#x2F;users&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">Call&lt;User&gt; getUser(@Path(&quot;id&quot;) String id, @Query(&quot;gender&quot;) String gender);</span><br></pre></td></tr></table></figure><h3 id="Post"><a href="#Post" class="headerlink" title="Post"></a>Post</h3><ul><li>用户增加或者修改资源</li><li>包含 body，发送给服务器的内容写在 body 里面</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST  &#x2F;users  HTTP&#x2F;1.1</span><br><span class="line">Host: api.github.com</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 13</span><br></pre></td></tr></table></figure><p>对应的 Retrofit 的代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@FormUrlEncoded</span><br><span class="line">@POST(&quot;&#x2F;users&quot;)</span><br><span class="line">Call&lt;User&gt; addUser(@Field(&quot;name&quot;) String name, @Field(&quot;gender&quot;) String</span><br><span class="line">gender);</span><br></pre></td></tr></table></figure><h3 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h3><ul><li>用于修改资源</li><li>包含 body，发送给服务器的内容写在 body 里面</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT  &#x2F;users&#x2F;1  HTTP&#x2F;1.1</span><br><span class="line">Host: api.github.com</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 13</span><br></pre></td></tr></table></figure><p>对应的 Retrofit 的代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@FormUrlEncoded</span><br><span class="line">@PUT(&quot;&#x2F;users&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">Call&lt;User&gt; updateGender(@Path(&quot;id&quot;) String id, @Field(&quot;gender&quot;) String</span><br><span class="line">gender);</span><br></pre></td></tr></table></figure><h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><ul><li>用于删除资源</li><li>不发送 body</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE  &#x2F;users&#x2F;1  HTTP&#x2F;1.1</span><br><span class="line">Host: api.github.com</span><br></pre></td></tr></table></figure><p>对应的 Retrofit 的代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@DELETE(&quot;&#x2F;users&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">Call&lt;User&gt; getUser(@Path(&quot;id&quot;) String id, @Query(&quot;gender&quot;) String gender);</span><br></pre></td></tr></table></figure><h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><ul><li><code>HEAD</code> 与 <code>GET</code> 的使用方式完全相同。</li><li>区别在于，<code>HEAD</code> 请求的返回响应中没有 <code>Body</code></li><li>用途：比如下载需求，返回的 Headers 中有下载内容的大小，可以用于显示进度。</li></ul><h3 id="小知识点"><a href="#小知识点" class="headerlink" title="小知识点"></a>小知识点</h3><p><code>GET</code>、<code>PUT</code>、<code>DELETE</code> 都是<strong>幂等</strong>操作，就是说，请求一次和请求多次的结果是一样的。<br>比如，GET 请求一个数据，请求一次和请求十次返回的结果是一样的，PUT 同样修改一个数据，修改一次和修改十次，结果也都是一样的。</p><h2 id="四、状态码-status-code"><a href="#四、状态码-status-code" class="headerlink" title="四、状态码(status code)"></a>四、状态码(status code)</h2><p>状态码是对结果进行类型化的描述的，比如「请求成功」、「内容未找到」等<br>主要分为 5 类。</p><h3 id="1xx：临时性消息。"><a href="#1xx：临时性消息。" class="headerlink" title="1xx：临时性消息。"></a>1xx：临时性消息。</h3>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">100：继续发送</span><br><span class="line">101：正在切换协议</span><br></pre></td></tr></table></figure><h3 id="2xx：成功。"><a href="#2xx：成功。" class="headerlink" title="2xx：成功。"></a>2xx：成功。</h3>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">200：OK (最常见) </span><br><span class="line">201：创建成功</span><br></pre></td></tr></table></figure><h3 id="3xx：重定向。"><a href="#3xx：重定向。" class="headerlink" title="3xx：重定向。"></a>3xx：重定向。</h3>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">301：域名永久移动</span><br><span class="line">302：暂时移动</span><br><span class="line">304：内容未改变，请求被重定向到客户端本地缓存</span><br></pre></td></tr></table></figure><h3 id="4xx：客户端错误"><a href="#4xx：客户端错误" class="headerlink" title="4xx：客户端错误"></a>4xx：客户端错误</h3>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">400：客户端请求错误，服务器不理解请求的语法。</span><br><span class="line">401：未授权，要求进行身份验证。</span><br><span class="line">403：被禁止，服务器拒绝请求。</span><br><span class="line">404：找不到内容，服务器找不到请求的网页。(最常见)</span><br></pre></td></tr></table></figure><h3 id="5xx：服务器错误"><a href="#5xx：服务器错误" class="headerlink" title="5xx：服务器错误"></a>5xx：服务器错误</h3>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">500：服务器内部错误 (最常见)</span><br><span class="line">503：服务不可用</span><br></pre></td></tr></table></figure><h2 id="五、首部-Headers"><a href="#五、首部-Headers" class="headerlink" title="五、首部(Headers)"></a>五、首部(Headers)</h2><p>首部包含多个请求头，是用来描述消息的元数据(meta data)。</p><p>首部字段有很多，主要分为以下几类：</p><ul><li>通用首部 =&gt; 提供了与报文相关的最基本的信息</li><li>请求首部 =&gt; 只在请求报文中有意义的首部</li><li>响应首部 =&gt; 只在响应报文中有意义的首部</li><li>body 首部 =&gt; 描述 body 的首部</li></ul><p>下面我们就说一些比较常用的。</p><h3 id="5-1-通用首部"><a href="#5-1-通用首部" class="headerlink" title="5.1 通用首部"></a>5.1 通用首部</h3><h4 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h4><p>提供日期和时间标志，说明报文是在什么时间创建的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Date: Tue, 12 Feb 2019 07:32:07 GMT</span><br></pre></td></tr></table></figure><h4 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h4><p>允许客户端和服务器指定与请求/响应连接有关的选项。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure><h4 id="其他通用首部"><a href="#其他通用首部" class="headerlink" title="其他通用首部"></a>其他通用首部</h4><p><strong>Via</strong> : 显示报文经过的中间节点（代理、网关）。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">via: cache25.l2ot7-1[0,304-0,H], cache25.l2ot7-1[1,0], cache5.us14[342,200-0,H]</span><br></pre></td></tr></table></figure><p><strong>Transfer-Encoding</strong> : 告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Transfer-Encoding: chunked</span><br></pre></td></tr></table></figure><p><strong>Cache-Control</strong> : 指定缓存的控制方式。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cache-control: no-store, no-cache, must-revalidate, proxy-revalidate</span><br></pre></td></tr></table></figure><h3 id="5-2-请求首部"><a href="#5-2-请求首部" class="headerlink" title="5.2 请求首部"></a>5.2 请求首部</h3><h4 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h4><p>给出了接收请求的服务器的主机名和端口。(注意:不是在网络上用于寻址的，⽽是在目标服务器上定位子服务器。)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Host: api.github.com</span><br></pre></td></tr></table></figure><h4 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h4><p>用来告诉<strong>服务端</strong>客户端会接受的媒体类型，包括客户端需要什么，可以使用什么，以及不想要什么。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8</span><br><span class="line"></span><br><span class="line">&#39;*&#39; 用来表示通配符。</span><br><span class="line">;q&#x3D; (q-factor weighting)</span><br><span class="line">值代表优先顺序，用相对质量价值表示，又称为权重。</span><br></pre></td></tr></table></figure><h4 id="Accept-Charset"><a href="#Accept-Charset" class="headerlink" title="Accept-Charset"></a>Accept-Charset</h4><p>用来告知服务器，客户端可以处理的字符集类型。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accept-Charset: utf-8, iso-8859-1;q&#x3D;0.5</span><br></pre></td></tr></table></figure><h4 id="Accept-Encoding"><a href="#Accept-Encoding" class="headerlink" title="Accept-Encoding"></a>Accept-Encoding</h4><p>用来将客户端能够理解的内容编码方式告知服务器，服务端会选择一个客户端提议的方式。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line"></span><br><span class="line">gzip：表示采用 Lempel-Ziv coding (LZ77) 压缩算法，以及32位CRC校验的编码方式。</span><br><span class="line">compress：采用 Lempel-Ziv-Welch (LZW) 压缩算法。</span><br><span class="line">deflate：采用 zlib 结构和 deflate 压缩算法。</span><br><span class="line">br：表示采用 Brotli 算法的编码方式。</span><br><span class="line">identity：用于指代自身（例如：未经过压缩和修改）。除非特别指明，这个标记始终可以被接受。</span><br></pre></td></tr></table></figure><h4 id="Accept-Language"><a href="#Accept-Language" class="headerlink" title="Accept-Language"></a>Accept-Language</h4><p>用来告诉服务器，客户端能够理解<strong>哪些语言</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9,en;q&#x3D;0.8</span><br></pre></td></tr></table></figure><h4 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h4><p>告诉服务器，客户端要获取哪段数据。<br>主要用于：<strong>断点续传</strong>、<strong>多线程下载</strong>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">Range: &lt;unit&gt;&#x3D;&lt;range-start&gt;-&lt;range-end&gt;, &lt;range-start&gt;-&lt;range-end&gt;, &lt;range-start&gt;-&lt;range-end&gt;</span><br><span class="line">&lt;unit&gt;：范围所采用的单位，通常是字节（bytes）。</span><br><span class="line">&lt;range-start&gt;：一个整数，表示在特定单位下，范围的起始值。</span><br><span class="line">&lt;range-end&gt;：一个整数，表示在特定单位下，范围的结束值。这个值是可选的，如果不存在，表示此范围一直延伸到文档结束。</span><br><span class="line"></span><br><span class="line">Range: bytes&#x3D;200-1000, 2000-6576, 19000-</span><br></pre></td></tr></table></figure><h4 id="From"><a href="#From" class="headerlink" title="From"></a>From</h4><p>提供了客户端用户的 E-mail 地址，<br>用处：比如你有一个爬虫程序，那么 Form 首部应该随请求一起发送，这样的话，在服务器遇到问题的时候，例如爬虫发送了过量的、不希望收到的或者不合法的请求时，站点管理员可以联系到你。</p><h3 id="5-3-响应首部"><a href="#5-3-响应首部" class="headerlink" title="5.3 响应首部"></a>5.3 响应首部</h3><h4 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h4><p>包含了处理请求的源头服务器所用到的软件相关信息</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Server: Apache-Coyote&#x2F;1.1</span><br></pre></td></tr></table></figure><h4 id="Set-Cookie"><a href="#Set-Cookie" class="headerlink" title="Set-Cookie"></a>Set-Cookie</h4><p>用来由服务器端向客户端发送 cookie。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">会话期 cookies 将会在客户端关闭时被移除。 </span><br><span class="line">会话期 cookie 不设置 Expires 或 Max-Age 指令</span><br><span class="line">Set-Cookie: sessionid&#x3D;38afes7a8; HttpOnly; Path&#x3D;&#x2F;</span><br><span class="line"></span><br><span class="line">持久化 Cookie 不会在客户端关闭时失效，而是在特定的日期（Expires）或者经过一段特定的时间之后（Max-Age）才会失效。</span><br><span class="line"></span><br><span class="line">Set-Cookie: id&#x3D;a3fWa; Expires&#x3D;Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly</span><br></pre></td></tr></table></figure><h4 id="Accept-Ranges"><a href="#Accept-Ranges" class="headerlink" title="Accept-Ranges"></a>Accept-Ranges</h4><p>响应中出现，表示服务器支持按字节来取范围数据</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Accept-Ranges: none</span><br><span class="line">none：不支持任何范围请求单位，由于其等同于没有返回此头部，因此很少使用。</span><br><span class="line">bytes：范围请求的单位是 bytes （字节）。</span><br><span class="line"></span><br><span class="line">Accept-Ranges: bytes</span><br></pre></td></tr></table></figure><h3 id="5-4-Body-首部"><a href="#5-4-Body-首部" class="headerlink" title="5.4 Body 首部"></a>5.4 Body 首部</h3><p>由于请求与响应中都可以包含 body部分，所以在请求报文与响应报文中都可以出现这部分字段。</p><h4 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h4><p>指定的是需要将页面重新定向至的地址。一般在响应码为 3xx 的响应中才会有意义。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Location: &#x2F;index.html</span><br></pre></td></tr></table></figure><h4 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h4><p>告诉客户端实际返回的内容的内容类型。<br><strong>主要分为一下 4 类:</strong></p><ul><li>text/html </li></ul><p>请求 Web ⻚面时返回响应的类型，Body 中返回 html 文本。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Content-Type: text&#x2F;html; charset&#x3D;utf-8</span><br><span class="line">Content-Length: 853</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br></pre></td></tr></table></figure><ul><li>x-www-form-urlencoded</li></ul><p>Web ⻚面纯⽂本表单的提交方式</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST  &#x2F;users  HTTP&#x2F;1.1</span><br><span class="line">Host: api.github.com</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 27</span><br><span class="line">name&#x3D;xxtlant&amp;gender&#x3D;male</span><br></pre></td></tr></table></figure><ul><li>multitype/form-data</li></ul><p>Web ⻚面含有⼆制⽂件时的提交方式。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST  &#x2F;users  HTTP&#x2F;1.1</span><br><span class="line">Host: hencoder.com</span><br><span class="line">Content-Type: multipart&#x2F;form-data; boundary&#x3D;----</span><br><span class="line">WebKitFormBoundary7MA4YWxkTrZu0gW</span><br><span class="line">Content-Length: 2382</span><br><span class="line">------WebKitFormBoundary7MA4YWxkTrZu0gW</span><br><span class="line">Content-Disposition: form-data; name&#x3D;&quot;name&quot;</span><br><span class="line">rengwuxian</span><br><span class="line">------WebKitFormBoundary7MA4YWxkTrZu0gW</span><br><span class="line">Content-Disposition: form-data; name&#x3D;&quot;avatar&quot;; filename&#x3D;&quot;avatar.jpg&quot;</span><br><span class="line">Content-Type: image&#x2F;jpeg</span><br><span class="line">JFIFHHvOwX9jximQrWa......</span><br><span class="line">------WebKitFormBoundary7MA4YWxkTrZu0gW--</span><br></pre></td></tr></table></figure><ul><li>application/json , image/jpeg , application/zip …</li></ul><p>单项内容(⽂本或非⽂本都可以)，用于 Web Api 的响应或者 POST / PUT 的请求。</p><blockquote><p>请求中提交 JSON</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;users HTTP&#x2F;1.1</span><br><span class="line">Host: api.github.com</span><br><span class="line">Content-Type: application&#x2F;json; charset&#x3D;utf-8</span><br><span class="line">Content-Length: 38</span><br><span class="line">&#123;&quot;name&quot;:&quot;xxtlant&quot;,&quot;gender&quot;:&quot;male&quot;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>响应中返回 JSON </p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Date: Tue, 12 Feb 2019 08:04:14 GMT</span><br><span class="line">Content-Type: application&#x2F;json; charset&#x3D;utf-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Server: GitHub.com</span><br><span class="line">Status: 200 OK</span><br><span class="line"></span><br><span class="line">&#123;&quot;login&quot;: &quot;xxtlant&quot;,</span><br><span class="line">&quot;id&quot;: 18342980,</span><br><span class="line">&quot;node_id&quot;: &quot;MDQ6VXNlcjE4MzQyOTgw&quot;,</span><br><span class="line">&quot;avatar_url&quot;: &quot;https:&#x2F;&#x2F;avatars2.githubusercontent.com&#x2F;u&#x2F;18342980?v&#x3D;4&quot;,</span><br><span class="line">&quot;gravatar_id&quot;: &quot;&quot;,</span><br><span class="line">....</span><br></pre></td></tr></table></figure><blockquote><p>请求中提交⼆进制内容</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;user&#x2F;1&#x2F;avatar HTTP&#x2F;1.1</span><br><span class="line">Host: hencoder.com</span><br><span class="line">Content-Type: image&#x2F;jpeg</span><br><span class="line">Content-Length: 1575</span><br><span class="line">JFIFHH9......</span><br></pre></td></tr></table></figure><blockquote><p>相应中返回⼆进制内容</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">content-type: image&#x2F;jpeg</span><br><span class="line">content-length: 1575</span><br><span class="line">JFIFHH9......</span><br></pre></td></tr></table></figure><h4 id="Content-length"><a href="#Content-length" class="headerlink" title="Content-length"></a>Content-length</h4><p>用来指明发送给接收方的消息主体的大小。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Length: &lt;length&gt;</span><br></pre></td></tr></table></figure><h4 id="Content-Encoding"><a href="#Content-Encoding" class="headerlink" title="Content-Encoding"></a>Content-Encoding</h4><p>用于对特定媒体类型的数据进行压缩。<br>这个消息用来告知客户端应该怎样解码才能获取在 Content-Type 中的媒体类型内容。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Encoding: gzip</span><br><span class="line"></span><br><span class="line">其值受 Accept-Encoding 影响</span><br></pre></td></tr></table></figure><p>与此对应，Content-Language 也与 Accept-Language 对应。</p><h2 id="六、参考链接"><a href="#六、参考链接" class="headerlink" title="六、参考链接"></a>六、参考链接</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP" target="_blank" rel="noopener">HTTP</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers" target="_blank" rel="noopener">HTTP Headers</a></li><li><a href="http://www.ruanyifeng.com/blog/2016/08/http.html" target="_blank" rel="noopener">HTTP 协议入门</a><!--more--></li></ul>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Google Cloud 搭建一年免费 Shadowsocks 教程</title>
      <link href="/posts/google_cloud_building_ssr.html"/>
      <url>/posts/google_cloud_building_ssr.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h4 id="以下内容，不需要编程基础"><a href="#以下内容，不需要编程基础" class="headerlink" title="以下内容，不需要编程基础"></a>以下内容，不需要编程基础</h4><ul><li>需要用到的工具<ul><li>可以访问 Google</li><li>信用卡一张</li><li>Google 账户</li></ul></li><li>如果没有科学上网工具，可以先下载使用 <a href="https://github.com/getlantern/forum/issues/833" target="_blank" rel="noopener">蓝灯免费版</a> 。</li></ul><a id="more"></a><h4 id="教程一共分为四步骤"><a href="#教程一共分为四步骤" class="headerlink" title="教程一共分为四步骤"></a>教程一共分为四步骤</h4><ol><li>使用 Google Cloud 部署虚拟机</li><li>升级VPS内核开启BBR</li><li>搭建 Shadowsocks Server</li><li>设置Shadowsocks server开机启动</li></ol><h3 id="一、-使用-Google-Cloud-部署虚拟机"><a href="#一、-使用-Google-Cloud-部署虚拟机" class="headerlink" title="一、 使用 Google Cloud 部署虚拟机"></a>一、 使用 Google Cloud 部署虚拟机</h3><h4 id="1-申请使用Google-Cloud"><a href="#1-申请使用Google-Cloud" class="headerlink" title="1.申请使用Google Cloud"></a>1.申请使用Google Cloud</h4><p>申请地址：<a href="https://cloud.google.com/free/" target="_blank" rel="noopener">点击此处</a></p><p>![Google Cloud 试用](../img/Google Cloud 试用.jpg)</p><p>![选择国家](../img/choose country.jpg)</p><p><img src="../img/%E5%A1%AB%E5%86%99%E5%9C%B0%E5%9D%80.jpg" alt=""></p><p><img src="../img/%E5%A1%AB%E5%86%99%E4%BF%A1%E7%94%A8%E5%8D%A1.jpg" alt="填写地址以及信用卡信息"></p><p>登陆 Google 账户，<strong>必须使用信用卡</strong>，而且不能使用虚拟卡，招商银行、中信银行的全币种卡、浦发银行的 VISA 卡均可以通过验证。理论上 VISA 卡均可获得通过，选择中国后绑定信用卡，填写个人信息，可如实填写信用卡账单地址。成功后会于扣款1刀，验证卡片后会返还。<br>GCD 现在免费赠送 300 刀期限是一年，也就是 300 刀和一年时间谁先用完就以谁为准，<strong>结束之后不点继续使用时不会扣费的</strong>。</p><p>跳转后，如果你能看到页面顶部有一个“礼物 🎁 ” 的小图标，或者说你收到了相应的邮件，说明试用金已到账</p><p><img src="/img/%E8%AF%95%E7%94%A8%E6%97%B6%E9%97%B4.jpg" alt="试用时间"></p><p>上图是我的剩余试用时间以及剩余赠金</p><h4 id="2-修改防火墙"><a href="#2-修改防火墙" class="headerlink" title="2.修改防火墙"></a>2.修改防火墙</h4><p>提前设置好后，后面设置完 ss 服务就可以直接使用了</p><p>访问链接：<a href="https://console.cloud.google.com/networking/firewalls/list" target="_blank" rel="noopener">点击此处</a></p><p>或者在菜单中依次点击【VPC 网络】 –&gt; 【防火墙规则】 –&gt; 【创建防火墙规则】</p><p><img src="/img/%E5%88%9B%E5%BB%BA%E9%98%B2%E7%81%AB%E5%A2%99%E8%A7%84%E5%88%99.jpg" alt="创建防火墙规则.jpg"></p><p>更改红色箭头指向的几项。<br>名称自己随意起，IP 地址范围：<strong>0.0.0.0/0</strong><br>点击创建会生成规则，请耐心等待。</p><h4 id="3-获取静态IP"><a href="#3-获取静态IP" class="headerlink" title="3.获取静态IP"></a>3.获取静态IP</h4><p>获取静态 IP 很重要，只有有了静态IP，后面部署的SS服务才能用。</p><p>设置地址:<a href="https://console.cloud.google.com/networking/addresses/list?project=allow-all-ip-port-xxtlant" target="_blank" rel="noopener">点击此处</a></p><p>或者在菜单中依次点击【VPC 网络】 –&gt; 【外部 IP 地址】 –&gt; 【保留静态地址】</p><p><img src="../img/%E4%BF%9D%E7%95%99%E9%9D%99%E6%80%81%E5%9C%B0%E5%9D%80.jpg" alt="保留静态地址.jpg"></p><p><strong>名称自定义即可</strong></p><p>PS：<strong>静态 IP 只能申请一个！！！</strong></p><p>大陆速度最佳的机房是台湾彰化的机房了，asia-east1-c对大陆最友好<br>还有东京亚洲东区，也就是东京机房了asia-northeast1-a</p><h4 id="4-创建计算引擎"><a href="#4-创建计算引擎" class="headerlink" title="4.创建计算引擎"></a>4.创建计算引擎</h4><p>设置地址:<a href="https://console.cloud.google.com/compute/instances" target="_blank" rel="noopener">点击此处</a></p><p>或者在菜单中依次点击【计算引擎】–&gt; 【创建实例】</p><p><img src="../img/%E5%88%9B%E5%BB%BA%E8%AE%A1%E7%AE%97%E5%AE%9E%E4%BE%8B.jpg" alt="创建计算实例.jpg"></p><p>如图，机器类型选最便宜的<strong>微型</strong>就够用，启动磁盘选<strong>Ubuntu16.04LTS</strong>，我参照的教程是使用Ubuntu1604，所以我选择了这个。<br>点击蓝色箭头指向的 【管理、磁盘、网络、SSH 密钥】，去设置网络。</p><p><img src="../img/%E8%AE%BE%E7%BD%AE%E7%BD%91%E7%BB%9C.jpg" alt="设置网络.jpg"></p><p><img src="../img/%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81%E5%9C%B0%E5%9D%80.jpg" alt="设置静态地址.jpg"></p><p>按图所示，点击 主要内部 IP 的保留静态 IP 地址，然后选择刚才创建的静态 IP 即可。点击创建即可完成。<br>等待一会后，出现下图所示，即已经完成创建。</p><p><img src="../img/%E5%AE%9E%E4%BE%8B.jpg" alt="实例.jpg"></p><p>至此，第一步已经完成。</p><h3 id="二、升级VPS内核开启BBR-这一步，我不懂，是参考搜到的教程来设定的"><a href="#二、升级VPS内核开启BBR-这一步，我不懂，是参考搜到的教程来设定的" class="headerlink" title="二、升级VPS内核开启BBR(这一步，我不懂，是参考搜到的教程来设定的)"></a>二、升级VPS内核开启BBR(这一步，我不懂，是参考搜到的教程来设定的)</h3><p>由于众所周知的原因，单纯部署完shadowsocks服务之后速度都不会太理想，即使你选择的是台湾、日本这种很好的线路，依然会存在丢包和不稳定的情况。</p><p>点击上图创建实例完成后，右边的 SSH。会弹出一个页面，如下图：</p><p>![SSH 页面.jpg](../img/SSH 页面.jpg)</p><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>进入 ssh 后，先获取 root 权限</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo –i</span><br></pre></td></tr></table></figure><p>更新系统，两步分开执行，第二步耗时久一些</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt upgrade</span><br></pre></td></tr></table></figure><p>查看当前内核</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uname –a</span><br></pre></td></tr></table></figure><h4 id="启用BBR"><a href="#启用BBR" class="headerlink" title="启用BBR"></a>启用BBR</h4><p>写入配置 两步分开执行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;net.core.default_qdisc&#x3D;fq&quot; &gt;&gt; &#x2F;etc&#x2F;sysctl.conf</span><br><span class="line"></span><br><span class="line">echo &quot;net.ipv4.tcp_congestion_control&#x3D;bbr&quot; &gt;&gt; &#x2F;etc&#x2F;sysctl.conf</span><br></pre></td></tr></table></figure><p>配置生效</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><p>检验</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lsmod | grep bbr</span><br></pre></td></tr></table></figure><p>看到显示<code>tcp_bbr 20480 xx</code> 说明已经成功开启 BBR。<strong>不需要重新启动</strong></p><p>至此，第二步已经结束，接下来直接开始在虚拟机部署 SS 服务。</p><h3 id="三、搭建-Shadowsocks-Server"><a href="#三、搭建-Shadowsocks-Server" class="headerlink" title="三、搭建 Shadowsocks Server"></a>三、搭建 Shadowsocks Server</h3><p>首先更新一下 apt-get 软件包</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p>然后通过 apt-get 安装 python-pip</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install python-pip</span><br></pre></td></tr></table></figure><p>完成之后使用 pip 安装 shadowsocks 服务</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pip install shadowsocks</span><br></pre></td></tr></table></figure><p><img src="../img/%E5%AE%89%E8%A3%85Shadowsocks.jpg" alt="安装Shadowsocks.jpg"></p><p>说明安装成功了。</p><p>然后我们需要创建一个 shadowsocks server 的配置文件，可以直接建在当前用户目录下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim &#x2F;etc&#x2F;ss-conf.json</span><br></pre></td></tr></table></figure><p>回车之后会进入这个创建的文件，<br>按键盘上的 i 键会进入编辑，然后把下面的内容输入进去。<br>按ESC键会发现左下角的insert消失，<br>使用组合键 <strong>shift 加 ：</strong> ，这个组合键左下角出现<strong>：</strong>，然后输入 <strong>wq</strong> 回车就保存退出文件。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;server&quot;:&quot;0.0.0.0&quot;,</span><br><span class="line">&quot;server_port&quot;:000,</span><br><span class="line">&quot;local_address&quot;:&quot;127.0.0.1&quot;,</span><br><span class="line">&quot;local_port&quot;:1080,</span><br><span class="line">&quot;password&quot;:&quot;123456&quot;,</span><br><span class="line">&quot;timeout&quot;:600,</span><br><span class="line">&quot;method&quot;:&quot;aes-256-cfb&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的内容复制到创建的文件里就可以了。</p><p><font size =4><strong>注意</strong></p><ol><li>代码的全部内容必须为<strong>英文半角输入</strong>，</li><li><strong>server_port</strong>与<strong>password</strong>后面的数字内容<strong>请自己设定</strong>，这两个是你之后在shadowsocks客户端上配置使用的<strong>端口和密码</strong>。</font></li></ol><p>最后用这个配置文件启动 shadowsocks 服务</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ssserver -c &#x2F;etc&#x2F;ss-conf.json -d start</span><br></pre></td></tr></table></figure><h3 id="四、开启-Shadowsocks-Server-开机启动"><a href="#四、开启-Shadowsocks-Server-开机启动" class="headerlink" title="四、开启 Shadowsocks Server 开机启动"></a>四、开启 Shadowsocks Server 开机启动</h3><p>服务器可能会自动重启，这样的话就需要每次手动开启SS服务，很麻烦而且还会遇到要用梯子但是梯子在墙外的这种困境，怎么办呢？那么我们进入第四步，写脚本让系统开机后自动启动ss服务。</p><p>创建脚本 /etc/init.d/shadowsocks</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim &#x2F;etc&#x2F;init.d&#x2F;shadowsocks</span><br></pre></td></tr></table></figure><p>进入文件后添加以下内容,方法与前面创建ss-conf.json这个文件一样，使用键盘字母 <strong>i</strong> 键、<strong>shif 加 ：</strong>、<strong>wq</strong>回车保存等等</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line">### BEGIN INIT INFO</span><br><span class="line"># Provides: shadowsocks</span><br><span class="line"># Required-Start: $remote_fs $syslog</span><br><span class="line"># Required-Stop: $remote_fs $syslog</span><br><span class="line"># Default-Start: 2 3 4 5</span><br><span class="line"># Default-Stop: 0 1 6</span><br><span class="line"># Short-Description: start shadowsocks</span><br><span class="line"># Description: start shadowsocks</span><br><span class="line">### END INIT INFO</span><br><span class="line">start()&#123;</span><br><span class="line">　　　ssserver -c &#x2F;etc&#x2F;ss-conf.json -d start</span><br><span class="line">&#125;</span><br><span class="line">stop()&#123;</span><br><span class="line">　　　ssserver -c &#x2F;etc&#x2F;ss-conf.json -d stop</span><br><span class="line">&#125;</span><br><span class="line">case “$1” in</span><br><span class="line">start)</span><br><span class="line">　　　start</span><br><span class="line">　　　;;</span><br><span class="line">stop)</span><br><span class="line">　　　stop</span><br><span class="line">　　　;;</span><br><span class="line">reload)</span><br><span class="line">　　　stop</span><br><span class="line">　　　start</span><br><span class="line">　　　;;</span><br><span class="line">*)</span><br><span class="line">　　　echo “Usage: $0 &#123;start|reload|stop&#125;”</span><br><span class="line">　　　exit 1</span><br><span class="line">　　　;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p>然后增加这个文件的可执行权限</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo chmod +x &#x2F;etc&#x2F;init.d&#x2F;shadowsocks</span><br></pre></td></tr></table></figure><p>创建文件 /etc/init/shadowsocks.conf</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim &#x2F;etc&#x2F;init&#x2F;shadowsocks.conf</span><br></pre></td></tr></table></figure><p>内容直接复制如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start on (runlevel [2345])stop on (runlevel [016])pre-start script</span><br><span class="line">&#x2F;etc&#x2F;init.d&#x2F;shadowsocks start</span><br><span class="line">end script</span><br><span class="line"></span><br><span class="line">post-stop script</span><br><span class="line">&#x2F;etc&#x2F;init.d&#x2F;shadowsocks stop</span><br><span class="line">end script</span><br></pre></td></tr></table></figure><p>执行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo update-rc.d shadowsocks defaults</span><br></pre></td></tr></table></figure><p>然后就添加到开机启动中了<br>最后你可以 <strong>Reboot</strong> 测试一下看是否成功，若未成功就check一下第四步哪里有问题。</p><p>至此搭建已经全部完成了。</p><p><img src="../img/Youtube%E6%B5%8B%E8%AF%95.jpg" alt="Youtube测试.jpg"></p><h3 id="SSR-客户端-下载地址"><a href="#SSR-客户端-下载地址" class="headerlink" title="SSR 客户端 下载地址"></a>SSR 客户端 <a href="http://shadowsocks.org/en/download/clients.html" target="_blank" rel="noopener">下载地址</a></h3><p>直接下载文件</p><p><a href="/img/ShadowsocksX-NG.1.7.1.zip">Mac 版</a></p><p><a href="/img/com.github.shadowsocks.apk">Android</a></p><!--more-->]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React Native 开发环境搭建</title>
      <link href="/posts/RN_develop_environment_building.html"/>
      <url>/posts/RN_develop_environment_building.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="什么是-React-Native"><a href="#什么是-React-Native" class="headerlink" title="什么是 React Native"></a>什么是 React Native</h2><blockquote><p>React Native (简称 RN)是 Facebook 于 2015 年开源的一套跨平台，动态更新的 JavaScript 框架。<br>口号是：Learn once, write anywhere: Build mobile apps with React<br>着力于提高多平台开发的开发效率 —— 仅需学习一次，编写任何平台。</p></blockquote> <a id="more"></a><h2 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h2><p>我用的电脑是 MacBook,搭建的环境是 MacOS + Android 。<br>其他例如搭建 iOS, Windows, Linux 的环境，请参考 <a href="http://reactnative.cn/docs/0.49/getting-started.html#content" target="_blank" rel="noopener">React Native 中文网的搭建开发环境</a> , <a href="http://facebook.github.io/react-native/docs/getting-started.html" target="_blank" rel="noopener">React Native 官方的 Getting Started</a> 这两篇文章。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="安装必须的软件"><a href="#安装必须的软件" class="headerlink" title="安装必须的软件"></a>安装必须的软件</h4><blockquote><p>需要安装 Node.js , Watchman, React Native命令行界面, JDK 和 Android Studio</p></blockquote><h5 id="HomeBrew"><a href="#HomeBrew" class="headerlink" title="HomeBrew"></a>HomeBrew</h5><p><a href="https://brew.sh/" target="_blank" rel="noopener">Homebrew</a>, Mac 系统的包管理器，用于安装 NodeJS 和其他一些必需的工具软件</p><blockquote><p>/usr/bin/ruby -e “$(curl -fsSL <a href="https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;" target="_blank" rel="noopener">https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</a></p></blockquote><p>直接复制上述命令，在终端运行就可以了。<br>译注：在Max OS X 10.11（El Capitan)版本中，homebrew在安装软件时可能会碰到/usr/local目录不可写的权限问题。可以使用下面的命令修复：</p><blockquote><p>sudo chown -R `whoami` /usr/local</p></blockquote><h5 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h5><p>使用 HomeBrew 来安装<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a></p><blockquote><p>brew install node</p></blockquote><p>安装完 node 后建议设置 npm 镜像以加速后面的过程（或使用科学上网工具）。注意：不要使用 cnpm！cnpm 安装的模块路径比较奇怪，packager不能正常识别！</p><blockquote><p>npm config set registry <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a> –global<br>npm config set disturl <a href="https://npm.taobao.org/dist" target="_blank" rel="noopener">https://npm.taobao.org/dist</a> –global</p></blockquote><h5 id="Yarn、React-Native的命令行工具（react-native-cli）"><a href="#Yarn、React-Native的命令行工具（react-native-cli）" class="headerlink" title="Yarn、React Native的命令行工具（react-native-cli）"></a>Yarn、React Native的命令行工具（react-native-cli）</h5><p><a href="https://yarnpkg.com/zh-Hans/" target="_blank" rel="noopener">Yarn</a> 是 Facebook 提供的替代 npm 的工具，可以加速 node 模块的下载。React Native 的命令行工具用于执行创建、初始化、更新项目、运行打包服务（packager）等任务。</p><blockquote><p>npm install -g yarn react-native-cli</p></blockquote><p>安装完 yarn 后也要设置镜像源:</p><blockquote><p>yarn config set registry <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a> –global<br>yarn config set disturl <a href="https://npm.taobao.org/dist" target="_blank" rel="noopener">https://npm.taobao.org/dist</a> –global</p></blockquote><p>如果你看到 <strong><code>EACCES: permission denied</code></strong> 这样的权限报错，那么请参照上文的 homebrew 译注，修复 <code>/usr/local</code> 目录的所有权：</p><blockquote><p>sudo chown -R `whoami` /usr/local</p></blockquote><p>安装完yarn之后就可以用 <code>yarn</code> 代替 <code>npm</code> 了，例如用 <code>yarn</code> 代替 <code>npm install</code> 命令，用 <code>yarn add</code> 某第三方库名代替 <code>npm install --save</code> 某第三方库名。 </p><h5 id="Java-开发工具包"><a href="#Java-开发工具包" class="headerlink" title="Java 开发工具包"></a>Java 开发工具包</h5><p>React Native需要最新版本的Java SE开发工具包（JDK）。如果需要，<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">下载并安装JDK 8或更高版本</a>。</p><h5 id="Android-开发环境"><a href="#Android-开发环境" class="headerlink" title="Android 开发环境"></a>Android 开发环境</h5><h6 id="1-安装-Android-Studio"><a href="#1-安装-Android-Studio" class="headerlink" title="1. 安装 Android Studio"></a>1. 安装 Android Studio</h6><p>下载并安装Android Studio 。如果可以科学上网，可以在<a href="https://developer.android.google.cn/index.html" target="_blank" rel="noopener">Android Developers</a> 下载，也可以在 <a href="http://www.android-studio.org/" target="_blank" rel="noopener">Android Studio 中文社区</a> 进行下载。<br>Android Studio包含了运行和测试React Native应用所需的Android SDK和模拟器。</p><blockquote><p>除非特别注明，请不要改动安装过程中的选项。比如Android Studio默认安装了 Android Support Repository，而这也是React Native必须的（否则在react-native run-android时会报appcompat-v7包找不到的错误）。</p></blockquote><p>安装过程中需要改动的选项:</p><ul><li>选择 <code>Custom</code> 选项:<br>  <img src="http://reactnative.cn/static/docs/0.49/img/react-native-android-studio-custom-install.png" alt="选择 Custom"></li><li>勾选 <code>Performance</code> 和 <code>Android Virtual Device</code><br>  <img src="http://reactnative.cn/static/docs/0.49/img/react-native-android-studio-additional-installs.png" alt="选择"></li><li>安装完成后，在 Android Studio 的启动欢迎界面中选择 <strong>Configure | SDK Manager</strong>。<br>  <img src="http://reactnative.cn/static/docs/0.49/img/react-native-android-studio-configure-sdk.png" alt="选择 SDK Manager"></li><li>在 <code>SDK Platforms</code> 窗口中，选择 <code>Show Package Details</code>，然后在Android 6.0 (Marshmallow)中勾选<ul><li><strong>Google APIs</strong></li><li><strong>Android SDK Platform 23</strong></li><li><strong>Intel x86 Atom_64 System Image</strong></li><li><strong>Google APIs Intel x86 Atom_64 System Image</strong><br><img src="http://reactnative.cn/static/docs/0.49/img/react-native-android-studio-android-sdk-platforms.png" alt="勾选指定项"></li></ul></li><li>在 <strong>SDK Tools</strong> 窗口中，选择 Show Package Details，然后在 Android SDK Build Tools 中勾选 <strong>Android SDK Build-Tools 23.0.1（必须是这个版本）</strong>。然后还要勾选最底部的 <strong>Android Support Repository</strong>.<br>  <img src="http://reactnative.cn/static/docs/0.49/img/react-native-android-studio-android-sdk-build-tools.png" alt="勾选 SDK Tools"></li></ul><h6 id="2-ANDROID-HOME-环境变量"><a href="#2-ANDROID-HOME-环境变量" class="headerlink" title="2. ANDROID_HOME 环境变量"></a>2. ANDROID_HOME 环境变量</h6><p>确保 <strong>ANDROID_HOME</strong> 环境变量正确地指向了你安装的 Android SDK 的路径。具体的做法是把下面的命令加入到 <code>~/.bash_profile</code> 文件中：(<strong>译注</strong>：~ 表示用户目录，即<code>/Users/你的用户名/</code>，而小数点开头的文件在 Finder 中是隐藏的，并且这个文件有可能并不存在。请在终端下使用 <code>vi ~/.bash_profile</code> 命令创建或编辑。如不熟悉 vi 操作，请点击<a href="http://www.eepw.com.cn/article/48018.htm" target="_blank" rel="noopener">这里</a> 学习）。如果你的命令行不是bash，而是例如 zsh 等其他，请使用对应的配置文件。</p><blockquote><p>如果你不是通过Android Studio安装的sdk，则其路径可能不同，请自行确定清楚。<br>export ANDROID_HOME=~/Library/Android/sdk</p></blockquote><p>然后使用下列命令使其立即生效（否则重启后才生效）：</p><blockquote><p>source ~/.bash_profile</p></blockquote><p>可以使用 <strong><code>echo $ANDROID_HOME</code></strong> 检查此变量是否已正确设置。</p><h5 id="Watchman"><a href="#Watchman" class="headerlink" title="Watchman"></a>Watchman</h5><p><a href="https://facebook.github.io/watchman/docs/install.html" target="_blank" rel="noopener">Watchman</a>是由 Facebook 提供的监视文件系统变更的工具。安装此工具可以提高开发时的性能（packager可以快速捕捉文件的变化从而实现实时刷新）。</p><blockquote><p>brew install watchman</p></blockquote><h5 id="将Android-SDK的Tools目录添加到PATH变量中"><a href="#将Android-SDK的Tools目录添加到PATH变量中" class="headerlink" title="将Android SDK的Tools目录添加到PATH变量中"></a>将Android SDK的Tools目录添加到PATH变量中</h5><p>把 Android SDK 的 tools 和 platform-tools 目录添加到 <strong>PATH</strong> 变量中，以便在终端中运行一些 Android 工具，例如 <code>android avd</code> 或是 <code>adb logcat</code> 等。具体做法仍然是在 <code>~/.bash_profile</code> 中添加：</p><blockquote><p>export PATH=$PATH:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools</p></blockquote><h4 id="其他可选的安装项"><a href="#其他可选的安装项" class="headerlink" title="其他可选的安装项"></a>其他可选的安装项</h4><h5 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h5><p>Git 版本控制。如若没有，则使用下列命令安装：</p><blockquote><p>brew install git</p></blockquote><h5 id="Nuclide"><a href="#Nuclide" class="headerlink" title="Nuclide"></a>Nuclide</h5><p><a href="https://nuclide.io/" target="_blank" rel="noopener">Nuclide</a> （此链接需要科学上网）是由 Facebook 提供的基于 <strong>atom</strong> 的集成开发环境，可用于编写、<a href="http://nuclide.io/docs/platforms/react-native/#running-applications" target="_blank" rel="noopener">运行</a>和 <a href="https://nuclide.io/docs/platforms/react-native/#debugging" target="_blank" rel="noopener">调试</a>React Native应用。</p><p>点击这里阅读<a href="http://nuclide.io/docs/quick-start/getting-started/" target="_blank" rel="noopener">Nuclide的入门文档</a>。</p><h5 id="Genymotion"><a href="#Genymotion" class="headerlink" title="Genymotion"></a>Genymotion</h5><p>Genymotion是一个性能更好的选择，但它只对个人用户免费。</p><ol><li>下载和安装<a href="https://www.genymotion.com/download" target="_blank" rel="noopener">Genymotion</a>（genymotion需要依赖VirtualBox虚拟机，下载选项中提供了包含VirtualBox和不包含的选项，请按需选择）。</li><li>打开Genymotion。如果你还没有安装VirtualBox，则此时会提示你安装。</li><li>创建一个新模拟器并启动。</li><li>启动React Native应用后，可以按下⌘+M来打开开发者菜单</li></ol><h5 id="Gradle-Daemon"><a href="#Gradle-Daemon" class="headerlink" title="Gradle Daemon"></a>Gradle Daemon</h5><p>开启 <a href="https://docs.gradle.org/2.9/userguide/gradle_daemon.html" target="_blank" rel="noopener">Gradle Daemon</a> 可以极大地提升java代码的增量编译速度。</p><blockquote><p>touch ~/.gradle/gradle.properties &amp;&amp; echo “org.gradle.daemon=true” &gt;&gt; ~/.gradle/gradle.properties</p></blockquote><h2 id="测试安装"><a href="#测试安装" class="headerlink" title="测试安装"></a>测试安装</h2><blockquote><p>react-native init AwesomeProject</p></blockquote><blockquote><p>cd AwesomeProject</p></blockquote><blockquote><p>react-native run-android</p></blockquote><blockquote><p>提示：你可以使用–version参数创建指定版本的项目。例如 react-native init MyApp –version 0.39.2。注意版本号必须精确到两个小数点.</p></blockquote><p>你也可以在 <a href="https://nuclide.io/" target="_blank" rel="noopener">Nuclide</a> 中打开AwesomeProject文件夹然后<a href="http://nuclide.io/docs/platforms/react-native/#running-applications" target="_blank" rel="noopener">运行</a>。</p><blockquote><p>注意，react-native run-android 时，需要打开一个 Android 设备的模拟器，不然会报错</p></blockquote><h3 id="其他问题。"><a href="#其他问题。" class="headerlink" title="其他问题。"></a>其他问题。</h3><p>如果看完这些，还有其他问题，请查阅 <a href="http://reactnative.cn/" target="_blank" rel="noopener">React Native 中文网</a>，里面有详细的使用文档。<br>或者参阅 <a href="http://facebook.github.io/react-native/" target="_blank" rel="noopener">Facebook 的 React Native 的官方文档</a>.</p><p>我也是一个初学者，谢谢。</p> <!--more-->]]></content>
      
      
      <categories>
          
          <category> React Native </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React Native </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 开发实用小技巧</title>
      <link href="/posts/android_develop_skill.html"/>
      <url>/posts/android_develop_skill.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="文本与布局"><a href="#文本与布局" class="headerlink" title="文本与布局"></a>文本与布局</h3><ol><li><p>字符串资源里的变量替换<br>当程序中使用字符串如第 345 页，我们不可能使用两个字符串资源如</p> <figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;string name="di"&gt;第&lt;/string&gt; </span><br><span class="line">&lt;string name="page"&gt;页&lt;/string&gt;</span><br></pre></td></tr></table></figure> <a id="more"></a><p>在 android 中有一个东西是 XLIFF，全称是 XML 本地化数据交换格式，英文是 XML Loca lization Interchange File Format。<br>用法很简单，如下所示</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;string name="page"&gt;第%1$s页&lt;/string&gt;</span><br><span class="line">程序中只要给变量赋值就好了，如下：</span><br><span class="line">String page = getString(R.string.page,<span class="string">"345"</span>);</span><br></pre></td></tr></table></figure><p>要是有多个变量，如第 345 页 24 行 ? 这也好办，如下:</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;string name="page"&gt;第%1$s页%2$s行&lt;/string&gt;</span><br><span class="line">String page = getString(R.string.page,<span class="string">"345"</span>,<span class="string">"24"</span>);</span><br></pre></td></tr></table></figure></li><li><p>TextView 设置多种字体大小</p><p><img src="https://github.com/xxtlant/BlogPicture/blob/master/android%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/TextViewSpan.png?raw=true" alt="TextView字体"></p><p>像这样的两种字体，要如何处理呢</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    String text = <span class="string">"Android实战技巧之文本与布局"</span>;</span><br><span class="line">    <span class="keyword">int</span> start = text.indexOf(<span class="string">'之'</span>);</span><br><span class="line">    <span class="keyword">int</span> end = text.length();</span><br><span class="line">    Spannable textSpan =  <span class="keyword">new</span> SpannableString(text);</span><br><span class="line">    textSpan.setSpan(<span class="keyword">new</span> AbsoluteSizeSpan(<span class="number">20</span>), <span class="number">0</span>, start,</span><br><span class="line">                    Spannable.SPAN_INCLUSIVE_INCLUSIVE);</span><br><span class="line">    textSpan.setSpan(<span class="keyword">new</span> AbsoluteSizeSpan(<span class="number">12</span>), start,</span><br><span class="line">                    end, Spannable.SPAN_INCLUSIVE_INCLUSIVE);</span><br><span class="line">    ``` </span><br><span class="line">    这个 textSpan 就是你想要的。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. TextView 的超链接</span><br><span class="line">  这个很简单，在 xml 中属性 `autoLink=“all”`。</span><br><span class="line">  程序中 `TextView.setAutoLink(Linkify.ALL)`;</span><br><span class="line">  说一下 `autoLink` 中的参数：</span><br><span class="line"></span><br><span class="line">    ```java</span><br><span class="line">    Linkify.EMAIL_ADDRESS -- 仅识别出 TextView 中的 Email 在址，标识为超链接，点击后会跳到 Email，发送邮件给此地址</span><br><span class="line">    Linkify.PHONE_NUMBERS -- 仅识别出 TextView 中的电话号码，标识为超链接，点击后会跳到 Dialer，Call 这个号码</span><br><span class="line">    Linkify.WEB_URLS-- 仅识别出 TextView 中的网址，标识为超链接，点击后会跳到 Browser 打开此 URL Linkify.ALL -- 这个选项是识别出所有系统所支持的特殊 Uri，然后做相应的操作</span><br></pre></td></tr></table></figure><p> 特殊情况:<br>当一段文字部分是超链接或者我们需要点击超链接跳到另一个 Activity时，如何处理?</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TextView testText;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        testText = (TextView) findViewById(R.id.testText); </span><br><span class="line">        <span class="comment">//将TextView的显示文字设置为SpannableString</span></span><br><span class="line">        testText.setText(getClickableSpan());</span><br><span class="line">        <span class="comment">//设置该句使文本的超连接起作用</span></span><br><span class="line">        testText.setMovementMethod(LinkMovementMethod.getInstance());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置超链接文字</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> SpannableString <span class="title">getClickableSpan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SpannableString spanStr = <span class="keyword">new</span> SpannableString(<span class="string">"使用该软件，即表示您同意该软件的使用条款和隐私政策"</span>); <span class="comment">//设置下划线文字</span></span><br><span class="line">        spanStr.setSpan(<span class="keyword">new</span> UnderlineSpan(), <span class="number">16</span>, <span class="number">20</span>, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); <span class="comment">//设置文字的单击事件</span></span><br><span class="line">        spanStr.setSpan(<span class="keyword">new</span> ClickableSpan() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View widget)</span> </span>&#123;</span><br><span class="line">                startActivity(<span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, TestActivity1<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">16</span>, <span class="number">20</span>, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);</span><br><span class="line">        <span class="comment">//设置文字的前景色</span></span><br><span class="line">        spanStr.setSpan(<span class="keyword">new</span> ForegroundColorSpan(Color.WHITE), <span class="number">16</span>, <span class="number">20</span>, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); <span class="comment">//设置下划线文字</span></span><br><span class="line">        spanStr.setSpan(<span class="keyword">new</span> UnderlineSpan(), <span class="number">21</span>, <span class="number">25</span>, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);</span><br><span class="line">        <span class="comment">//设置文字的单击事件</span></span><br><span class="line">        spanStr.setSpan(<span class="keyword">new</span> ClickableSpan() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View widget)</span> </span>&#123;</span><br><span class="line">                startActivity(<span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, TestActivity2<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">21</span>, <span class="number">25</span>, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);</span><br><span class="line">        <span class="comment">//设置文字的前景色</span></span><br><span class="line">        spanStr.setSpan(<span class="keyword">new</span> ForegroundColorSpan(Color.WHITE), <span class="number">21</span>, <span class="number">25</span>, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);</span><br><span class="line">        <span class="keyword">return</span> spanStr;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line">4. Java 文件中字体加粗</span><br><span class="line"></span><br><span class="line">    &#96;&#96;&#96;java</span><br><span class="line">    &#x2F;&#x2F;Typeface </span><br><span class="line">    textView.setTypeface(Typeface.defaultFromStyle(Typeface.BOLD));</span><br><span class="line">    &#x2F;&#x2F;use TextPaint</span><br><span class="line">    textView.getPaint().setFakeBoldText(true);</span><br></pre></td></tr></table></figure></li></ol><h3 id="按钮控制-ViewPager-的左右翻页"><a href="#按钮控制-ViewPager-的左右翻页" class="headerlink" title="按钮控制 ViewPager 的左右翻页"></a>按钮控制 ViewPager 的左右翻页</h3><p>为了实现左右翻页的效果，使用了 ViewPager，它会很方便的实现左右滑动后翻页。 这时需要自己也加上两个 button 来实现同样的操作，如何实现呢?<br>通过查看 ViewPager 的源码，里面有一个公共方法 arrowScroll ，查看代码 们可以有两个重要的发现:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">executeKeyEvent</span><span class="params">(KeyEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (event.getAction() == KeyEvent.ACTION_DOWN) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (event.getKeyCode()) &#123;</span><br><span class="line">                <span class="keyword">case</span> KeyEvent.KEYCODE_DPAD_LEFT: <span class="comment">//键盘方向键左键的控制，向左翻页</span></span><br><span class="line">                    handled = arrowScroll(FOCUS_LEFT);<span class="comment">//FOCUS_LEFT:17</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> KeyEvent.KEYCODE_DPAD_RIGHT:<span class="comment">//键盘方向键右键的控制，向右翻页</span></span><br><span class="line">                    handled = arrowScroll(FOCUS_RIGHT);<span class="comment">//FOCUS_RIGHT:66</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> KeyEvent.KEYCODE_TAB:</span><br><span class="line">                    <span class="keyword">if</span> (event.hasNoModifiers()) &#123;</span><br><span class="line">                        handled = arrowScroll(FOCUS_FORWARD);<span class="comment">// 向前 -&gt; 右翻 FOCUS_FORWARD:2</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.hasModifiers(KeyEvent.META_SHIFT_ON)) &#123;</span><br><span class="line">                        handled = arrowScroll(FOCUS_BACKWARD);<span class="comment">// 向后 -&gt; 左翻 FOCUS_BACKWARD:1</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">arrowScroll</span><span class="params">(<span class="keyword">int</span> direction)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (nextFocused != <span class="keyword">null</span> &amp;&amp; nextFocused != currentFocused) &#123;</span><br><span class="line">            <span class="keyword">if</span> (direction == View.FOCUS_LEFT) &#123;</span><br><span class="line">                ... <span class="comment">// 省略一些无关代码</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (direction == View.FOCUS_RIGHT) &#123;</span><br><span class="line">                ... <span class="comment">// 省略一些无关代码</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (direction == FOCUS_LEFT || direction == FOCUS_BACKWARD)&#123; <span class="comment">// 17 or 1 向左翻页</span></span><br><span class="line">            <span class="comment">// Trying to move left and nothing there; try to page.</span></span><br><span class="line">            handled = pageLeft();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (direction == FOCUS_RIGHT || direction == FOCUS_FORWARD) &#123; <span class="comment">// 66 or 2 向右翻页</span></span><br><span class="line">            <span class="comment">// Trying to move right and nothing there; try to page.</span></span><br><span class="line">            handled = pageRight();</span><br><span class="line">        &#125;</span><br><span class="line">        ... <span class="comment">//省略一些无关代码</span></span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>也就是说， 我们调用 arrowScroll 方法用参数 1 或者 17 就可以实现向左翻页;参数 2 或 66 就可以实现向右翻页。 后记:<br>当你的 UI 中有 EditText 这种获得 focus 的 widget 时， 必须用 17 和 66，否则要报错。</p><h3 id="获得屏幕物理尺寸、密度及分辨率"><a href="#获得屏幕物理尺寸、密度及分辨率" class="headerlink" title="获得屏幕物理尺寸、密度及分辨率"></a>获得屏幕物理尺寸、密度及分辨率</h3><h4 id="获取屏幕的宽高"><a href="#获取屏幕的宽高" class="headerlink" title="获取屏幕的宽高"></a>获取屏幕的宽高</h4><p>需要注意的原来经常使用的 getHeight() 与 getWidth() 已经不推荐使用了，建议使用 getSize()来替代。</p><p>参数是一个返回参数，用以返回分辨率的 Point，这个 Point 也比较简单，我们只需要关注 x 和 y 这两个成员就可以了。<br>用法如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSize</span><span class="params">(Point outSize)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        updateDisplayInfoLocked();  </span><br><span class="line">        mDisplayInfo.getAppMetrics(mTempMetrics, mDisplayAdjustments);</span><br><span class="line">        outSize.x = mTempMetrics.widthPixels;</span><br><span class="line">        outSize.y = mTempMetrics.heightPixels;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外 <code>Display</code>又提供了另一个方法：<code>getRealSize()</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getRealSize</span><span class="params">(Point outSize)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        updateDisplayInfoLocked();</span><br><span class="line">        outSize.x = mDisplayInfo.logicalWidth; </span><br><span class="line">        outSize.y = mDisplayInfo.logicalHeight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从两个方法的实现上看是有区别的。那么差异究竟在哪里，下面做一些实验来验证一下。<br>当<code>Activity</code>的主题是全屏主题时 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">android:theme=<span class="string">"@android:style/Theme.Black.NoTitleBar.Fullscreen"</span> </span><br><span class="line">android:theme=<span class="string">"@android:style/Theme.NoTitleBar.Fullscreen"</span></span><br></pre></td></tr></table></figure><p>二者返回的宽高是一样的，但是当不是全屏主题是，例如 <code>Activity</code> 主题有<code>ToolBar/ActionBar</code>时，二者返回的宽高就不一样了。<br>测试如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getSize():</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getDisplaySize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Point point = <span class="keyword">new</span> Point(); getWindowManager().getDefaultDisplay().getSize (point);     </span><br><span class="line">    Log.d(TAG,<span class="string">"the screen size is "</span>+point.toString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果如下 返回的高度是去掉 toolbar 的高度</span></span><br><span class="line">D/SecondActivity: <span class="function">the screen size is <span class="title">Point</span><span class="params">(<span class="number">1080</span>, <span class="number">1794</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">getRealSize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getDisplayInfomation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Point point = <span class="keyword">new</span> Point(); getWindowManager().getDefaultDisplay().getSize (point);</span><br><span class="line">    Log.d(TAG,<span class="string">"the screen size is "</span>+point.toString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果如下 是屏幕真实的宽高</span></span><br><span class="line">D/SecondActivity: <span class="function">the screen size is <span class="title">Point</span><span class="params">(<span class="number">1080</span>, <span class="number">1920</span>)</span></span></span><br></pre></td></tr></table></figure><h4 id="屏幕尺寸，设备的物理屏幕尺寸"><a href="#屏幕尺寸，设备的物理屏幕尺寸" class="headerlink" title="屏幕尺寸，设备的物理屏幕尺寸"></a>屏幕尺寸，设备的物理屏幕尺寸</h4><ol><li><p>屏幕尺寸，设备的物理屏幕尺寸<br> 现如今 <code>Android</code> 手机尺寸杂乱无章，有规则的，也有奇葩的尺寸，<a href="http://screensiz.es/" target="_blank" rel="noopener">手机屏幕尺寸</a> 这个网站，记录了一些 <code>Android、IOS</code> 屏幕的尺寸比例。<br> 不同的屏幕尺寸是可以通过采用相同的分辨率，它们之间的区别就在于<strong>密度(density)</strong>不同</p></li><li><p>那些搞晕你的单位：DPI / PPI / DP / PX<br> APP 中尺寸单位和各自的意思</p><table><thead><tr><th>尺寸单位</th><th align="left">代表的意思</th></tr></thead><tbody><tr><td>px: pixel</td><td align="left">【像素】  电子屏幕上组成一幅图画或照片的最基本单元</td></tr><tr><td>pt: ponit</td><td align="left">【点】印刷行业常用单位，等于1/72英寸</td></tr><tr><td>ppi: pixel per inch</td><td align="left">【每英寸像素数】  该值越高，则屏幕越细腻</td></tr><tr><td>dpi: dot per inch</td><td align="left">【每英寸像素数】  该值越高，则屏幕越细腻</td></tr><tr><td>dp/dip:Density-independent pixel</td><td align="left">安卓开发用的长度单位，1dp表示在屏幕像素点密度为160ppi时1px长度</td></tr><tr><td>sp: scale-independent pixel</td><td align="left">安卓开发用的字体大小单位</td></tr></tbody></table><p> <strong>相互关系</strong></p><ul><li><p>pt 和 px</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>pt = (DPI / <span class="number">72</span>)px</span><br></pre></td></tr></table></figure><p> 当在 ps 中新建画布的分辨率为 72ppi(即72dpi),1pt = 1px</p></li><li><p>PPI 和 DPI<br> DPI 最初适用于衡量打印物上每英寸的点数密度。DPI 值越小图片越不精细。当 DPI 的概念用在计算机屏幕上时，就称为了 PPI。同理：PPI 就是计算机屏幕上每英寸可以显示的像素点的数量。因此，在电子屏幕中提到的 PPI 和 DPI 是一致的。</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">可认为 DPI = PPI</span><br></pre></td></tr></table></figure></li><li><p>PPI 的计算方法<br>  <img src="http://upload-images.jianshu.io/upload_images/3303429-c7a1c80febcc85a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ppi 的计算方法">    </p></li><li><p>px 和 dp<br>dp为安卓开发时的长度单位，根据不同的屏幕分辨率，与px有不同的对应关系。<br>dp的大小的定义为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>dp=（屏幕 ppi / <span class="number">160</span>）px</span><br></pre></td></tr></table></figure><p><img src="https://github.com/xxtlant/BlogPicture/blob/master/android%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/dpi%E4%B8%8E%E5%AF%86%E5%BA%A6%E7%9A%84%E6%8D%A2%E7%AE%97.png?raw=true" alt="DPI 与 PPI"></p></li><li><p>dp 和 sp<br>dp和sp类似，都会随着屏幕大小和分辨率变化而改变，不同的是，在android中，dp表示长度单位，sp表示字体大小，在多数情况下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>dp=<span class="number">1</span>sp</span><br></pre></td></tr></table></figure><p>但是在文字尺寸是“大”或“超大”时，1sp &gt; 1dp。</p><!--more--></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 实战技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Studio 常用插件整理</title>
      <link href="/posts/AS_plug.html"/>
      <url>/posts/AS_plug.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>最近改用 Android Studio 3.0 preview ,顺便整理一下，常用的插件。</p><h4 id="GsonFormat"><a href="#GsonFormat" class="headerlink" title="GsonFormat"></a><span style="font-size: 12pt;"><a href="https://plugins.jetbrains.com/plugin/7654-gsonformat" target="_blank" rel="noopener">GsonFormat</a></span></h4><p> 将 Json 字符串快速转成 JavaBean 对象，免去我们根据 Json 字符串手写对应 Java Bean 的过程.</p><p><img src="https://plugins.jetbrains.com/files/7654/screenshot_15729.png" alt="gsonFormat"><br>Tips: 可以使用快捷键 alt + s (windows)  / option + s (mac) </p><a id="more"></a><h4 id="Android-ButterKnife-Zelezny"><a href="#Android-ButterKnife-Zelezny" class="headerlink" title="Android ButterKnife Zelezny"></a><span style="font-size: 12pt;"><a href="https://plugins.jetbrains.com/plugin/7369-android-butterknife-zelezny" target="_blank" rel="noopener">Android ButterKnife Zelezny</a></span></h4><p>配合 <a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="noopener">butterknife</a> 实现注解，不用再手动实现 findViewById 了。</p><p><img src="https://plugins.jetbrains.com/files/7369/screenshot_14384.png" alt="Android ButterKnife Zelezny"></p><h4 id="Android-Methods-Count"><a href="#Android-Methods-Count" class="headerlink" title="Android Methods Count"></a><span style="font-size: 12pt;"><a href="https://plugins.jetbrains.com/plugin/8076-android-methods-count" target="_blank" rel="noopener">Android Methods Count</a></span></h4><p> 显示依赖库中得方法数<br><img src="https://plugins.jetbrains.com/files/8076/screenshot_15509.png" alt="Android Methods Count"></p><h4 id="Lifecycle-Sorter"><a href="#Lifecycle-Sorter" class="headerlink" title="Lifecycle Sorter"></a><span style="font-size: 12pt;"><a href="https://plugins.jetbrains.com/plugin/7742-lifecycle-sorter" target="_blank" rel="noopener">Lifecycle Sorter</a></h4><p> 可以根据Activity或者fragment的生命周期对其生命周期方法位置进行先后排序， windows 快捷键Ctrl + alt + K . Mac 快捷键 option + command + K.<br><img src="https://plugins.jetbrains.com/files/7742/screenshot_15070.png" alt="Lifecycle Sorter"></p><h4 id="Android-Code-Generator"><a href="#Android-Code-Generator" class="headerlink" title="Android Code Generator"></a><span style="font-size: 12pt;"><a href="https://plugins.jetbrains.com/plugin/7595-android-code-generator" target="_blank" rel="noopener">Android Code Generator</a></span></h4><p> 根据布局文件快速生成对应的Activity，Fragment，Adapter，Menu。<br><img src="https://plugins.jetbrains.com/files/7595/screenshot_14834.png" alt="Android Code Generator"></p><h4 id="Android-Parcelable-code-generator"><a href="#Android-Parcelable-code-generator" class="headerlink" title="Android Parcelable code generator"></a><span style="font-size: 12pt;"><a href="https://plugins.jetbrains.com/plugin/7332-android-parcelable-code-generator" target="_blank" rel="noopener">Android Parcelable code generator</a></span></h4><p> JavaBean 序列化，快速实现 Parcelable 接口。<br><img src="https://segmentfault.com/image?src=http://img.blog.csdn.net/20160416104459926&objectId=1190000005092842&token=ab29ed79d41be9e42b3a3d2ed1ec3bef" alt="Android Parcelable code generator"></p><h4 id="CodeGlance"><a href="#CodeGlance" class="headerlink" title="CodeGlance"></a><span style="font-size: 12pt;"><a href="https://plugins.jetbrains.com/plugin/7275-codeglance" target="_blank" rel="noopener">CodeGlance</a></span></h4><p> 在右边实现代码预览，类似于 sublime ，快速定位。<br><img src="https://plugins.jetbrains.com/files/7275/screenshot_16821.png" alt="CodeGlance"></p><h4 id="FindBugs-IDEA"><a href="#FindBugs-IDEA" class="headerlink" title="FindBugs-IDEA"></a><span style="font-size: 12pt;"><a href="https://plugins.jetbrains.com/plugin/3847-findbugs-idea" target="_blank" rel="noopener">FindBugs-IDEA</a></span></h4><p> 查找 bug 的插件。具体使用可见 freddyyao 的简书文章 -&gt; <a href="http://www.jianshu.com/p/bc27857c89e4" target="_blank" rel="noopener">代码缺陷扫描神器——FindBugs</a><br><img src="https://plugins.jetbrains.com/files/3847/screenshot_2542.png" alt="FindBugs-IDEA"></p><h4 id="ADB-WIFI"><a href="#ADB-WIFI" class="headerlink" title="ADB WIFI"></a><span style="font-size: 12pt;"><a href="https://plugins.jetbrains.com/plugin/7856-adb-wifi" target="_blank" rel="noopener">ADB WIFI</a></span></h4><p> 使用wifi无线调试你的app，无需root权限<br><img src="https://plugins.jetbrains.com/files/7856/screenshot_15153.png" alt="ADB WIFI"></p><h4 id="JSONOnlineViewer"><a href="#JSONOnlineViewer" class="headerlink" title="JSONOnlineViewer"></a><span style="font-size: 12pt;"><a href="https://plugins.jetbrains.com/plugin/7838-jsononlineviewer" target="_blank" rel="noopener">JSONOnlineViewer</a></span></h4><p> 在 Android Studio 中，请求、调试接口<br><img src="https://plugins.jetbrains.com/files/7838/screenshot_15113.png" alt="JSONOnlineViewer"></p><h4 id="Android-Styler"><a href="#Android-Styler" class="headerlink" title="Android Styler"></a><span style="font-size: 12pt;"><a href="https://plugins.jetbrains.com/plugin/7972-android-styler" target="_blank" rel="noopener">Android Styler</a></span></h4><p> 根据 xml 自动生成 style 代码的插件。 需要把要生成 style 的代码 copy 到 styles.xml 中，选中进行设置。<br><img src="https://plugins.jetbrains.com/files/7972/screenshot_15340.png" alt=""><br><img src="https://plugins.jetbrains.com/files/7972/screenshot_15339.png" alt=""><br><img src="https://plugins.jetbrains.com/files/7972/screenshot_15338.png" alt="Android Styler"></p><h4 id="Android-Drawable-Importer"><a href="#Android-Drawable-Importer" class="headerlink" title="Android Drawable Importer"></a><span style="font-size: 12pt;"><a href="https://plugins.jetbrains.com/plugin/7658-android-drawable-importer" target="_blank" rel="noopener">Android Drawable Importer</a></span></h4><p> 这是一个非常强大的图片导入插件。它导入Android图标与Material图标的Drawable ，批量导入Drawable ，多源导入Drawable（即导入某张图片各种dpi对应的图片）<br><img src="https://plugins.jetbrains.com/files/7658/screenshot_15533.png" alt=""><br><img src="https://plugins.jetbrains.com/files/7658/screenshot_15532.png" alt=""><br><img src="https://plugins.jetbrains.com/files/7658/screenshot_15534.png" alt=""><br><img src="https://plugins.jetbrains.com/files/7658/screenshot_15536.png" alt=""><br><img src="https://plugins.jetbrains.com/files/7658/screenshot_15351.png" alt="Android Drawable Importer"></p><h4 id="Genymotion"><a href="#Genymotion" class="headerlink" title="Genymotion"></a><span style="font-size: 12pt;"><a href="https://plugins.jetbrains.com/plugin/7269-genymotion" target="_blank" rel="noopener">Genymotion</a></span></h4><p> 一款速度较快的 Android 模拟器，可以在 Android Studio 中直接开启。<br><img src="https://plugins.jetbrains.com/files/7269/screenshot_14278.png" alt="Genymotion"></p><h4 id="SQLScout"><a href="#SQLScout" class="headerlink" title="SQLScout"></a><span style="font-size: 12pt;"><a href="https://plugins.jetbrains.com/plugin/8322-sqlscout-sqlite-support-" target="_blank" rel="noopener">SQLScout</a></span></h4><p> 在 Android Studio 中调试数据库 (SQLite)</p><p>详细使用参考：<a href="https://juejin.im/post/58e0d781a0bb9f0069ec08d3" target="_blank" rel="noopener">在 Android Studio 上调试数据库 ( SQLite )</a><br><img src="https://plugins.jetbrains.com/files/8322/screenshot_15823.png" alt="SQLScout"></p><h4 id="GradleDependenciesHelperPlugin"><a href="#GradleDependenciesHelperPlugin" class="headerlink" title="GradleDependenciesHelperPlugin"></a><span style="font-size: 12pt;"><a href="https://github.com/ligi/GradleDependenciesHelperPlugin" target="_blank" rel="noopener">GradleDependenciesHelperPlugin</a></span></h4><p> maven gradle 依赖支持自动补全<br><img src="http://upload-images.jianshu.io/upload_images/3303429-15b6eed60db1bbde?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="GradleDependenciesHelperPlugin"></p><h4 id="RemoveButterKnife"><a href="#RemoveButterKnife" class="headerlink" title="RemoveButterKnife"></a><span style="font-size: 12pt;"><a href="https://github.com/u3shadow/RemoveButterKnife" target="_blank" rel="noopener">RemoveButterKnife</a></span></h4><p> ButterKnife这个第三方库每次更新之后，绑定view的注解都会改变，从bind,到inject，再到bindview，搞得很多人都不敢升级，一旦升级，就会有巨量的代码需要手动修改，非常痛苦当我们有一些非常棒的代码需要拿到其他项目使用，但是我们发现，那个项目对第三方库的使用是有限制的，我们不能使用butterknife，这时候，我们又得从注解改回findviewbyid针对上面的两种情况，如果view比较少还好说，如果有几十个view，那么我们一个个的手动删除注解，写findviewbyid语句，简直是一场噩梦（别问我为什么知道这是噩梦）所以，这种有规律又重复简单的工作为什么不能用一个插件来实现呢？于是RemoveButterKnife的想法就出现了。<br><a href="http://www.u3coding.com/2016/06/24/androidstudio-plugin-removebutterknife-di/" target="_blank" rel="noopener">具体介绍</a></p><p><img src="http://upload-images.jianshu.io/upload_images/3303429-43ff9b5a2e3a1405?imageMogr2/auto-orient/strip" alt="RemoveButterKnife"></p><h4 id="AndroidProguardPlugin"><a href="#AndroidProguardPlugin" class="headerlink" title="AndroidProguardPlugin"></a><span style="font-size: 12pt;"><a href="https://github.com/zhonghanwen/AndroidProguardPlugin" target="_blank" rel="noopener">AndroidProguardPlugin</a></span></h4><p> 一键生成项目混淆代码插件，值得你安装~<br><img src="https://camo.githubusercontent.com/adef227c0dc014f53b6e2a46977ef9ff2ceeb5a4/687474703a2f2f3778726e6b6f2e636f6d312e7a302e676c622e636c6f7564646e2e636f6d2f616e64726f696470726f6775617264312e676966" alt="AndroidProguardPlugin"></p><h4 id="EventBus3-Intellij-Plugin"><a href="#EventBus3-Intellij-Plugin" class="headerlink" title="EventBus3 Intellij Plugin"></a><span style="font-size: 12pt;"><a href="https://plugins.jetbrains.com/plugin/8603-eventbus3-intellij-plugin" target="_blank" rel="noopener">EventBus3 Intellij Plugin</a></span></h4><p> 为 EventBus 提供快速索引和跳转（目前只支持 EventBus 3.x 版本）<br>从 EventBus.post 到 @Subscribe 或者 onEventMainThread<br>从 @Subscribe 到 EventBus.post</p><p><img src="https://plugins.jetbrains.com/files/8603/screenshot_16147.png" alt="EventBus3 Intellij Plugin"></p><h4 id="Android-Studio-Prettify"><a href="#Android-Studio-Prettify" class="headerlink" title="Android Studio Prettify"></a><span style="font-size: 12pt;"><a href="https://plugins.jetbrains.com/plugin/7405" target="_blank" rel="noopener">Android Studio Prettify</a></span></h4><p> 可以将代码中的字符串写在string.xml文件中<br>选中字符串鼠标右键选择图中所示<br><img src="https://plugins.jetbrains.com/files/7405/screenshot_14418.png" alt="Android Studio Prettify"></p><h4 id="ignore"><a href="#ignore" class="headerlink" title=".ignore"></a><span style="font-size: 12pt;"><a href="https://plugins.jetbrains.com/plugin/7495--ignore" target="_blank" rel="noopener">.ignore</a></span></h4><p> 在Git 中想要过滤掉一些不想提交的文件，可以把相应的文件添加到.gitignore 中，而.gitignore 这个Android Studio 插件根据不同的语言来选择模板，就不用自己在费事添加一些文件了，而且还有自动补全功能，过滤文件再也不要复制文件名了。<br>我们做项目的时候，并不是所有文件都是要提交的，比如构建的build 文件夹，本地配置文件，每个Module 生成的iml 文件，但是我们每次add，commit 都会不小心把它们添加上去，而gitignore 就是解决这种痛点的，如果你不想提交的文件，就可以在创建项目的时候将这个文件中添加即可，将一些通用的东西屏蔽掉。</p><p><img src="https://plugins.jetbrains.com/files/7495/screenshot_14959.png" alt=".ignore"></p><h4 id="Markdown-Navigator"><a href="#Markdown-Navigator" class="headerlink" title="Markdown Navigator"></a><span style="font-size: 12pt;"><a href="https://plugins.jetbrains.com/plugin/7896-markdown-navigator" target="_blank" rel="noopener">Markdown Navigator</a></span></h4><p> markdown插件</p><p><img src="https://plugins.jetbrains.com/files/7896/screenshot_15818.png" alt="Markdown Navigator"></p><h4 id="ECTranslation"><a href="#ECTranslation" class="headerlink" title="ECTranslation"></a><span style="font-size: 12pt;"><a href="https://plugins.jetbrains.com/plugin/8469-ectranslation" target="_blank" rel="noopener">ECTranslation</a></span></h4><p> Android Studio 翻译插件,可以将英文翻译为中文.</p><p><img src="https://github.com/Skykai521/ECTranslation/raw/master/img/translation_img.png" alt="ECTranslation"></p><h4 id="Codota"><a href="#Codota" class="headerlink" title="Codota"></a><span style="font-size: 12pt;"><a href="http://www.codota.com/" target="_blank" rel="noopener">Codota</a></span></h4><p> 搜索最好的Android代码.</p><h4 id="Exynap"><a href="#Exynap" class="headerlink" title="Exynap"></a><span style="font-size: 12pt;"><a href="https://plugins.jetbrains.com/plugin/8600-exynap" target="_blank" rel="noopener">Exynap</a></span></h4><p> Exynap 一个帮助开发者自动生成样板代码的 AndroidStudio 插件<br><img src="https://plugins.jetbrains.com/files/8600/screenshot_16141.png" alt="Exynap"></p><h4 id="MVPHelper"><a href="#MVPHelper" class="headerlink" title="MVPHelper"></a><span style="font-size: 12pt;"><a href="https://plugins.jetbrains.com/plugin/8507-mvphelper" target="_blank" rel="noopener">MVPHelper</a></span></h4><p> 一款Intellj IDEA 和Android Studio的插件，可以为MVP生成接口以及实现类，解放双手。<br>具体请查看<a href="http://androidwing.net/index.php/27" target="_blank" rel="noopener">Android Studio插件之MVPHelper，一键生成MVP代码</a>一文<br><img src="https://github.com/githubwing/MVPHelper/raw/master/img/mvp_presenter.gif" alt="MVPHelper"></p><h4 id="ADB-Idea"><a href="#ADB-Idea" class="headerlink" title="ADB Idea"></a><span style="font-size: 12pt;"><a href="https://plugins.jetbrains.com/plugin/7380-adb-idea" target="_blank" rel="noopener">ADB Idea</a></span></h4><p> 一键清理缓存、卸载，重启 APP</p><p><img src="http://upload-images.jianshu.io/upload_images/3303429-2989b94e026cc0cd.gif?imageMogr2/auto-orient/strip" alt="adb-idea.gif"></p><!--more-->]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Android Studio </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
