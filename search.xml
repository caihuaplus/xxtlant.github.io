<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>单例模式深入解析</title>
      <link href="/posts/singleton.html"/>
      <url>/posts/singleton.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong>单例模式</strong>是应用最广的设计模式之一，也是程序员最熟悉的一个设计模式，<strong>使用单例模式的类必须保证只能有创建一个对象</strong>。</p><p>今天主要是回顾一下单例模式，主要是想搞懂以下几个问题</p><ul><li>为什么要使用单例？</li><li>如何实现一个单例？</li><li>单例存在哪些问题？</li><li>单例对象的作用域的范围</li><li>单例模式是如何保证唯一性的</li></ul><h2 id="为什么要使用单例？"><a href="#为什么要使用单例？" class="headerlink" title="为什么要使用单例？"></a>为什么要使用单例？</h2><p>在开发过程中，很多时候一个类我们希望它<strong>只创建一个对象</strong>，比如：线程池、缓存、网络请求等。当这类对象有多个实例时，程序就可能会出现异常，比如：程序出现异常行为、得到的结果不一致等。</p><p><strong>这时候就应该使用单例模式。</strong></p><p>单例主要有这两个优点：</p><p><strong>1、提供了对唯一实例的受控访问。</strong></p><p>2、由于在系统内存中只存在一个对象，<strong>因此可以节约系统资源，</strong>对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能。</p><h2 id="实现单例的-5-种方式"><a href="#实现单例的-5-种方式" class="headerlink" title="实现单例的 5 种方式"></a>实现单例的 5 种方式</h2><p>实现单例模式主要有以下几个关键点：</p><ol><li><strong>构造函数设置为 private</strong> ，这避免外部通过 new 创建实例；</li><li>通过一个<strong>静态方法或者枚举返回单例类对象</strong>；</li><li>考虑对象创建时的线程安全问题，确保单例类的对象<strong>有且仅有一个</strong>，尤其是在多线程环境下；</li><li>确保单例类对象在反序列化时不会重新构建对象。</li><li>考虑是否支持延迟加载；</li></ol><p><strong>下面是常见的集中单例模式的实现方式</strong></p><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p>在类加载的期间，<strong>就已经将 instance 静态实例初始化好了</strong>，所以，instance 实例的创建是线程安全的。不过，这样的实现方式<strong>不支持延迟加载实例。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><p>懒汉式相对于饿汉式的优势是<strong>支持延迟加载</strong>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但它的缺点也很明显，getInstance 使用了 <code>synchronize</code>  实现线程同步，导致这个方法的并发很低，每次调用都会频繁的枷锁、释放锁，会导致性能瓶颈。</p><h3 id="双重检测"><a href="#双重检测" class="headerlink" title="双重检测"></a>双重检测</h3><p>饿汉式不能延时加载，懒汉式有性能问题，而<strong>双重检测方式</strong>既支持延迟加载、又支持高并发的单例实现方式。</p><p>当 instance 对象被创建后，再次调用 getInstance 方法不再会进入 synchronize 加锁的代码之中。</p><p>它的优点是：资源利用率高，第一次执行 getInstance 时才会被实例化，效率高。缺点是：第一次加载反应稍慢。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时候，面试官会问这种实现方式有什么问题。<strong>他们指的就是指令重排序。</strong></p><p><code>instance = new Singleton();</code> 并不是一个原子操作， 这句代码实际执行了三件事。</p><p>1、 给 <code>Singleton</code> 的实例分配内存；</p><p>2、调用 <code>Singleton</code> 的构造函数，初始化成员变量；</p><p>3、将 <code>instance</code> 的对象指向分配的内存空间。</p><p>因为 Java 编译器<strong>允许处理器乱序执行</strong>，2、3的顺序是无法保证的。如果是 1-3-2 执行的顺序，当执行完 3 、2未执行之前，被切换到 B 线程，此时 instance 已经非空，B 会直接取走 instance，在使用时就会出错。</p><p>这就是<strong>指令重排</strong>。</p><p>解决办法也很简单：只需要给 instance 成员变量加上 <strong>volatile</strong> 关键字，就可以禁止指令重排序。</p><p>其实这个问题在高版本的 java 中已经被解决了，解决方式也很简单，就是把对象 new 操作和初始化操作设计为原子操作，就自然能禁止重排序。</p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>除了以上方法外，使用 Java 的静态内部类也能够实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Instance</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Instance.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当第一次加载 Singleton 类时并不会初始化 instance，只有在第一次调用 Singleton 的 getInstance 方法时才会导致 instance 被初始化。</p><p>第一次调用 getInstance 方法时会导致虚拟机加载 Instance 类，这种方式不仅能保证线程安全，也能够保证单例对象唯一，同时也延迟了单例的实例化。</p><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举是单例最简单的实现方式，这种实现方式通过 Java 枚举类型本身的特性，<strong>保证了实例创建的线程安全性和实例的唯一性。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单例存在哪些问题？"><a href="#单例存在哪些问题？" class="headerlink" title="单例存在哪些问题？"></a>单例存在哪些问题？</h2><h3 id="对-OOP-特性的支持不友好"><a href="#对-OOP-特性的支持不友好" class="headerlink" title="对 OOP 特性的支持不友好"></a>对 OOP 特性的支持不友好</h3><p>面向对象的四大特征是：<strong>封装、继承、多态。</strong>单例对继承、多态特性的支持不友好。</p><p>虽然从理论上来讲，单例类也可以被继承、也可以实现多态，但实现起来会非常奇怪。所以，一旦将某个类设计成到单例类，也就意味着放弃了继承和多态这两个面向对象的特性，也就相当于损失了可以应对未来需求变化的扩展性。</p><p>###单例对代码的扩展性不友好</p><p>我们知道，<strong>单例类只能有一个对象实例</strong>。但如果未来改需求了，需要创建两个或多个实例，就需要对代码有比较大的改动。</p><h3 id="单例不支持有参数的构造函数"><a href="#单例不支持有参数的构造函数" class="headerlink" title="单例不支持有参数的构造函数"></a>单例不支持有参数的构造函数</h3><p>单例不支持有参数的构造函数，如果想要传递参数，只能在 getInstance 方法中添加参数，或者定义方法传递参数。 </p><h3 id="针对这些问题，有何替代的解决方案？"><a href="#针对这些问题，有何替代的解决方案？" class="headerlink" title="针对这些问题，有何替代的解决方案？"></a>针对这些问题，有何替代的解决方案？</h3><p>为了保证全局唯一，除了使用单例，还可以用<strong>静态方法来实现</strong>。不过，静态方法这种实现思路，<strong>并不能解决之前提到的问题</strong>。</p><p>实际上，它比单例更加不灵活，比如，它无法支持延迟加载。</p><p>目前并没有什么很好的方式来解决。</p><h2 id="单例对象的作用域的范围"><a href="#单例对象的作用域的范围" class="headerlink" title="单例对象的作用域的范围"></a>单例对象的作用域的范围</h2><p>单例模式的类只能创建一个对象，<strong>这个对象的作用域是整个 APP 的生命周期，也就是进程中唯一。</strong></p><p>当我们打开 APP 后，系统会开启一个进程，并分配给 APP，接着进程会一条一条地执行 APP 文件中包含的代码，比如 当读到 <code>User user = new User();</code> 这条语句的时候，它就在自己的地址空间中创建一个 user 临时变量和一个 User 对象。</p><p><strong>进程之间是不共享地址空间的</strong>，如果我们的 APP 开启多个进程，那么每个进程都会分配新的地址空间，<strong>单例模式就会失效。</strong>。</p><p><strong>单例类中对象的唯一性的作用范围是进程内的，在进程间是不唯一的</strong>。</p><h2 id="单例模式是如何保证唯一性的"><a href="#单例模式是如何保证唯一性的" class="headerlink" title="单例模式是如何保证唯一性的"></a>单例模式是如何保证唯一性的</h2><p>这里就需要了解<strong>JVM 的类加载机制</strong>。</p><p>虚拟机的类加载是采用<strong>双亲委派模型</strong>。</p><p>它的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会去加载这个类，而是把这个请求<strong>委派给父类加载器去完成</strong>，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到<strong>顶层的启动类加载器中</strong>，只有当父加载器反馈自己无法完成这个加载请求（<strong>他的搜索范围中，没有找到这个类</strong>），子加载器才会去尝试加载。</p><p><img src="https://s2.ax1x.com/2019/08/26/mR4hKe.jpg" alt=""></p><p>所以，当单例模式的类被实例化后，因为<strong>这个类已经加载过了，</strong>再次请求加载时，就不会创建新的，而是会找到已经存在的这个类。</p><p>本文就到这里，单例模式虽然比较常用，但是它的知识点还是挺多的。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解 Java 中的多线程</title>
      <link href="/posts/java_thread.html"/>
      <url>/posts/java_thread.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h2><p><strong>进程是资源分配的最小单位，线程是CPU调度的最小单位</strong>。</p><p>进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是拥有资源和独立运行的最小单位，也是程序运行的最小单位。</p><p>线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。</p><p><strong>一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间。</strong></p><p>打个比方就是，<strong>CPU 相当于一个工厂，而进程相当于一个车间，线程相当于车间中的工人。</strong></p><h3 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h3><ul><li><p><strong>Thread 和 Runnable</strong></p><ul><li><strong>Thread</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> Thread thread = <span class="keyword">new</span> Thread() &#123; </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">      System.out.println(<span class="string">"Thread started!"</span>);</span><br><span class="line">&#125; </span><br><span class="line"> &#125;;</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure><ul><li><strong>Runnable</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runnable runnable = <span class="keyword">new</span> Runnable() &#123; </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Thread with Runnable started!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure></li><li><p><strong>ThreadFactory</strong></p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadFactory factory = <span class="keyword">new</span> ThreadFactory() &#123; </span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    count ++;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Thread(r, <span class="string">"Thread-"</span> + count); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Runnable runnable = <span class="keyword">new</span> Runnable() &#123; </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">"started!"</span>); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Thread thread = factory.newThread(runnable); </span><br><span class="line">thread.start();</span><br><span class="line">Thread thread1 = factory.newThread(runnable); </span><br><span class="line">thread1.start();</span><br></pre></td></tr></table></figure><ul><li><strong>Executor 和线程池</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> Runnable runnable = <span class="keyword">new</span> Runnable() &#123; </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Thread with Runnable started!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;;</span><br><span class="line">Executor executor = Executors.newCachedThreadPool(); </span><br><span class="line">executor.execute(runnable);</span><br><span class="line">executor.execute(runnable); </span><br><span class="line">executor.execute(runnable);</span><br></pre></td></tr></table></figure><h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><p>线程的生命周期包括 5 个部分：<strong>新建、就绪、运行、阻塞、销毁</strong>。</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/19/16417a1fd6b14a80?imageView2/0/w/1280/h/960" alt=""></p><ul><li><strong>新建（NEW），表示线程被创建出来还没真正启动的状态，可以认为它是个Java内部状态。</strong></li><li><strong>就绪（RUNNABLE），就是调用的线程的start()方法后。表示该线程已经在JVM中执行，当然由于执行需要计算资源，它可能是正在运行，也可能还在等待系统分配给它CPU片段，在就绪队列里面排队。</strong></li><li><strong>运行，当就绪的线程被调度并获得CPU资源时，便进入运行状态，run方法定义了线程的操作和功能;</strong></li><li>Java 的Thread.State 中，关于等待有三个常量表示。<ul><li><strong>阻塞（BLOCKED），阻塞表示线程在等待Monitor lock。比如，线程试图通过synchronized去获取某个锁，但是其他线程已经独占了，那么当前线程就会处于阻塞状态</strong></li><li><strong>等待（WAITING），表示正在等待其他线程采取某些操作。</strong>比如调用 sleep()、wait() 、join() 之后，线程就处于了阻塞状态，这个时候需要其他机制将处于阻塞状态的线程唤醒，比如调用 notify 或者 notifyAll() 方法。唤醒的线程不会立刻执行run方法，它们要再次等待CPU分配资源进入运行状态;</li><li><strong>计时等待（TIMED_WAIT），其进入条件和等待状态类似，但是调用的是存在超时条件的方法，比如wait或join等方法的指定超时版本</strong></li></ul></li><li><strong>销毁（TERMINATED），如果线程正常执行完毕后或线程被提前强制性的终止或出现异常导致结束，那么线程就要被销毁，释放资源;</strong></li></ul><h3 id="为什么一个线程不能-2-次-start"><a href="#为什么一个线程不能-2-次-start" class="headerlink" title="为什么一个线程不能 2 次 start()"></a>为什么一个线程不能 2 次 start()</h3><p>一个线程只能启动一次，在第二次调用 start() 方法的时候，线程可能处于终止或者其他（非 NEW）状态，但是不论如何，都是不可以再次启动的</p><h3 id="影响线程状态的因素"><a href="#影响线程状态的因素" class="headerlink" title="影响线程状态的因素"></a>影响线程状态的因素</h3><p><strong>1、线程自身的方法。</strong></p><p>sleep()：在指定时间内让当前正在执行的线程暂定执行，但不会释放锁标志。</p><p>yield()：暂停当前正在执行的线程对象，告诉调度器，主动让出 CPU；</p><p>join()：等待该线程终止。</p><p><strong>2、基于 Object 提供的 wait/notify/notifyAll 方法。</strong>如果我们持有某个对象的 Monitor 锁，调用 wait 会让当前线程处于等待状态，直到其他线程 notify 或者 notifyAll。所以，本质上是提供了 Monitor 的获取和释放的能力，是基本的线程间通信方式。</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>线程池是事先将多个线程对象放入到一个容器中，使用的时候直接去容器中拿，而不是new一个新的线程。节省了开辟子线程的时间，提高了写代码的执行效率。</p><h3 id="1、线程池一共有几种。"><a href="#1、线程池一共有几种。" class="headerlink" title="1、线程池一共有几种。"></a>1、线程池一共有几种。</h3><p><strong>1. newCachedThreadPool，可缓存的线程池</strong>，不固定线程数量，有空闲线程就复用，没有就新建，一定程度上减少了频繁创建/销毁小城，减少系统的开销。</p><p><strong>2.newFixedThreadPool，固定数量的线程池，</strong>可控制线程的最大并发数，超出的线程会在队列中等待。</p><p><strong>3.newSingleThreadPool，单线程的线程池，</strong>有且只有一个线程执行任务，所有的任务都按照指定的顺序执行，即遵循入队出队的规则。</p><p><strong>4.newScheduleThreadPool，支持定时以制定周期循环执行任务的线程池</strong></p><p>前三种线程池是 ThreadPoolExecutor 不同配置的实例，最后一种是 ScheduledThreadPoolExecutor  的实例。</p><h3 id="2、线程池的原理"><a href="#2、线程池的原理" class="headerlink" title="2、线程池的原理"></a>2、线程池的原理</h3><p>ThreadPoolExecutor 的创建有 7 个参数：核心线程数、最大线程数、线程存活时间、时间单位、工作队列、线程工厂、Handler。</p><p>从数据结构的角度来看，线程池主要参用了阻塞队列和HashSet的存储方式。</p><p>从任务执行的角度来看，线程池的机制是这样的。</p><p><strong>1、如果正在运行的线程数 &lt; coreSize，马上创建核心线程执行该task，不排队等待；</strong></p><p><strong>2、如果正在运行的线程数 &gt;= coreSize，把该task放入阻塞队列；</strong></p><p><strong>3、如果队列已满 &amp;&amp; 正在运行的线程数 &lt; maximumPoolSize，创建新的非核心线程执行该task；</strong></p><p><strong>4、如果队列已满 &amp;&amp; 正在运行的线程数 &gt;= maximumPoolSize，线程池调用handler的reject方法拒绝本次提交</strong>。</p><h3 id="3、线程池的线程复用-了解"><a href="#3、线程池的线程复用-了解" class="headerlink" title="3、线程池的线程复用(了解)"></a>3、线程池的线程复用(了解)</h3><p>ThreadPoolExecutor 中 executor 执行时，会把传入的 Runnable 通过 addWorker 方法，将 Runnable 包装成 Worker 对象，并将 Worker 添加到 workers 集合中，如果添加成功后，当执行 run 方法时，就会执行 worker 内部的run方法。</p><p>Worker 是 ThreadPoolExecutor 的内部类，它的构造方法制定了第一个要执行的任务 firstTask，并通过线程池的线程工厂创建线程。</p><p>当执行 run 方法时，最终会调用 runWorker 方法。 runWorker 方法是线程复用的核心。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// runWorker</span></span><br><span class="line">Runnable task = w.firstTask;</span><br><span class="line">w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line"><span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        w.lock();</span><br></pre></td></tr></table></figure><p>Worker 继承了 AbstractQueueSynchronizer , 在执行每个任务之前，通过 lock 方法加锁，执行完后，通过 unlock 解锁，使用这种机制来防止运行中任务被中断。</p><p>在执行任务时，先尝试获取 firstTask，即构造方法传入的<code>runnable</code>对象，然后尝试从<code>getTask</code> 方法获取任务队列中的任务。<strong>在任务执行前还要再次判断线程池是否已经处于STOP状态或者线程被中断。</strong></p><p>woker 线程的执行流程就是首先执行初始化时分配给的任务，执行完成以后会尝试从阻塞队列中获取可执行的任务，如果指定时间内仍然没有任务可以执行，则进入销毁逻辑调用<code>processWorkerExit()</code>方法。</p><p><strong>注：这里只会回收 corePoolSize 与 maximumPoolSize 直接的那部分 woker</strong></p><p><code>getTask()</code>方法<strong>通过一个循环不断轮询任务队列有没有任务到来</strong>，首先判断线程池是否处于正常运行状态，根据超时配置有两种方法取出任务：</p><ol><li>BlockingQueue.poll <strong>阻塞指定的时间尝试获取任务</strong>，如果超过指定的时间还未获取到任务就返回null。</li><li>BlockingQueue.take <strong>这种方法会在取到任务前一直阻塞</strong>。</li></ol><p>FixedThreadPool使用的是 take 方法，所以会线程会一直阻塞等待任务。CachedThreadPool使用的是 poll 方法，也就是说 CachedThreadPool 中的线程如果在60秒内未获取到队列中的任务就会被终止。</p><p>其实就是任务在并不只执行创建时指定的firstTask第一任务，还会从任务队列的中通过getTask()方法自己主动去取任务执行，而且是有/无时间限定的阻塞等待，保证线程的存活。</p><h2 id="线程同步与线程安全"><a href="#线程同步与线程安全" class="headerlink" title="线程同步与线程安全"></a>线程同步与线程安全</h2><p>当多个线程同时对一个资源进行修改时，由于CPU时间调度上的问题，写入的数据可能回被多次的覆盖，所以就要使线程同步。</p><h3 id="什么是线程安全？"><a href="#什么是线程安全？" class="headerlink" title="什么是线程安全？"></a>什么是线程安全？</h3><p>线程安全就是当多个线程访问某个类时，不管运行环境采用哪种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这类都能表现出正确的行为，那这个类就是线程安全的。</p><h4 id="线程安全的三特性"><a href="#线程安全的三特性" class="headerlink" title="线程安全的三特性"></a>线程安全的三特性</h4><p><strong>原子性</strong></p><blockquote><p>对共享内存的操作必须是要么全部执行直到执行结束，且中间过程不能被任何外部因素打断，要么就不执行。</p></blockquote><p><strong>可见性</strong></p><blockquote><p>一个线程修改了某个共享变量，执行结果能够及时的同步到共享内存，确保其他线程对此结果及时可见。</p><p>volatile 就是负责保证可见性的。</p></blockquote><p><strong>有序性</strong></p><blockquote><p>是保证线程内串行语义，避免指令重排等。</p></blockquote><h3 id="线程同步的方式有哪些？"><a href="#线程同步的方式有哪些？" class="headerlink" title="线程同步的方式有哪些？"></a>线程同步的方式有哪些？</h3><h4 id="1、synchronize"><a href="#1、synchronize" class="headerlink" title="1、synchronize"></a><strong>1、synchronize</strong></h4><p><strong>synchronized</strong>：保证方法内部或者代码块内部的资源(数据)的互斥访问。即同一时间、最多只有一个线程能获取到监视锁(Monitor)对象。当线程A尝试获取线程B持有的锁时，线程A只能等待或者阻塞，直到线程B释放锁。</p><p>synchronized 能够在方法或者代码块上加锁，默认的 monitor 是类对象，如果有多个 monitor 对象，它们之间不互斥。</p><p><strong>synchronized 加锁的作用</strong></p><p>1、<strong>保证监视资源的可见性</strong>。保证多线程环境下对监视资源的数据同步。即任何线程在获取到 monitor 后的第一时间，会先将共享内存中的数据复制到自己的缓存中；任何线程在释放 Monitor 的第一时间，会将缓存中的数据同步到共享内存中。</p><p>2、<strong>保证线程间操作的原子性</strong>。</p><p>同一时间只能由最多只能有一个线程访问，因此 synchronized 加锁的代码，要么不执行，要么全部执行完毕。</p><p>3、保证有序性，双重锁单例模式的指令重排问题，在高版本的 java 已经解决了这个问题。</p><p>解决的方法很简单，只要把对象 new 操作和初始化操作设计为原子操作，就自然能禁止重排序</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Shop <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Shop<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ( sInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                sInstance = <span class="keyword">new</span> Shop(); <span class="comment">// A</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在双重锁校验的单例模式中， <code>sInstance = new Shop()</code> 这句代码实际执行了三件事。</p><p>1、 给 Shop 的实例分配内存；</p><p>2、调用 Shop 的构造函数，初始化成员变量；</p><p>3、将 sInstance 的对象指向分配的内存空间。</p><p>但 Java 编译器允许处理器乱序执行，2、3的顺序是无法保证的。如果是 1-3-2 执行的顺序，当执行完 3 、2未执行之前，被切换到 B 线程，此时 sInstance 已经非空，B 会直接取走 sInstance，在使用时就会出错。</p><p>这就是<strong>指令重排</strong>。</p><p>解决办法也很简单：只需要给 instance 成员变量加上 volatile 关键字，就可以禁止指令重排序。</p><h4 id="2、Lock-锁"><a href="#2、Lock-锁" class="headerlink" title="2、Lock 锁"></a>2、Lock 锁</h4><p>使用 <strong>Lock</strong> 锁也能够实现多线程同步。</p><p><strong>Lock</strong>定义了一系列的锁操作方法。它提供了一种<strong>无条件的、可轮询的、定时的以及可中断的</strong>锁获取方式，所有的加锁和解锁的方法都是显式调用的。</p><p>Lock 的子类有 ReentrantLock、ReentrantReadWriteLock。ReentrantLock 提供了与 synchronized 相同的互斥性和内存可见性。</p><p><strong>Lock 锁需要手动释放锁，不然会一直持有锁对象，永不释放。</strong></p><ul><li>读写锁。</li></ul><p>读写锁的加锁策略是，允许多个读操作同时进行，但每次只允许一个写操作。</p><h4 id="3、-volatile"><a href="#3、-volatile" class="headerlink" title="3、 volatile"></a>3、 volatile</h4><p><strong>volatile 不能保证线程安全。</strong></p><p>volatile 只能够<strong>保证修饰字段的原子性和同步性</strong>，但<strong>如果对该变量执行的是非原子操作线程依旧是不安全的</strong>。</p><p>变量被 volatile 修饰后，编译器与运行时会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排。</p><p><strong>注意</strong>，volatile 只对基本类型的赋值和对象引用赋值的操作有效。</p><p>volatile 不能确保递增操作（count++）的原子性。volatile 只能保证可见性。</p><h4 id="4、Atomic"><a href="#4、Atomic" class="headerlink" title="4、Atomic"></a>4、Atomic</h4><p><strong>Atomic</strong>包提供了一系列的 AtomicInteger、AtomicBoolean 等类，<strong>使用这些类来声明变量，可以保证对其的操作具有原子性来保证线程安全。</strong></p><p>atomic 采用的是 CAS（CompareAndSwap）的操作原理，即无锁操作，一种乐观锁策略，原理就是多线程环境下各线程访问共享变量不会加锁阻塞排队，线程不会被挂起。通俗来讲就是一直循环对比，如果有访问冲突则重试，直到没有冲突为止。</p><p>至于 Android 中的多线程与线程间通信，我会单开一篇。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文看懂 HTTPS 协议</title>
      <link href="/posts/https_protocol.html"/>
      <url>/posts/https_protocol.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>HTTP 是超文本传输协议，具体请看这篇文章<a href="http://caihuasay.com/posts/http_analysis.html">HTTP 协议完全解析</a></p><p>HTTPS 是在 HTTP 之上加了一个安全层，虽然 HTTPS 实际上还是使用 HTTP 进行通信，但使用 SSL/TLS 对数据包进行了加密，能够保护交换数据的隐私与完整性。</p><h2 id="一、HTTP-的缺点"><a href="#一、HTTP-的缺点" class="headerlink" title="一、HTTP 的缺点"></a>一、HTTP 的缺点</h2><p>HTTP 主要有以下三种不足。</p><ul><li>通信使用明文(不加密)，内容可能会被窃听；</li><li>不验证通信方的身份，有可能会被伪装；</li><li>无法证明报文的完整性，有可能会被篡改。</li></ul><h3 id="1、通信使用明文可能会被窃听"><a href="#1、通信使用明文可能会被窃听" class="headerlink" title="1、通信使用明文可能会被窃听"></a>1、通信使用明文可能会被窃听</h3><p>由于 HTTP 本身不具备加密的功能，所以 HTTP 的报文都是使用明文的方式发送。使用 Fiddler、Charles 这类抓包工具时，也能发现 HTTP 的请求是明文，因此也很容易被拦截、获取、修改。</p><h4 id="为什么通信时不加密是一个缺点？"><a href="#为什么通信时不加密是一个缺点？" class="headerlink" title="为什么通信时不加密是一个缺点？"></a>为什么通信时不加密是一个缺点？</h4><p>我们都知道 HTTP 是基于 TCP/IP 的通信协议，而 TCP/IP 是可能被窃听的网络。</p><p>客户端向服务端发送一个 HTTP 请求，这个请求在网络中的传播路径是辐射式的，附近的节点网络都会收到这个请求，<strong>所以，消息很容易会被有心人窃听。</strong></p><p><img src="https://pic.downk.cc/item/5efae5a614195aa5948256af.png" alt=""></p><p>即使已经经过加密处理的通信，也会被窃听，<strong>只不过通信加密后，能让窃听者无法破解报文信息的含义。</strong></p><h4 id="加密处理防止被窃听"><a href="#加密处理防止被窃听" class="headerlink" title="加密处理防止被窃听"></a>加密处理防止被窃听</h4><p>加密的方式可以分为两种：<strong>通信加密、内容加密</strong></p><p><strong>1、通信加密</strong></p><p>HTTP 协议中没有加密机制，但可以通过和 SSL（Secure Socket Layer，安全套接层）或 TLS（Transport Layer Security，安全传输层协议）组合使用，加密 HTTP 的通信内容，<strong>也就是使用 HTTPS 进行通信。</strong></p><p><strong>2、内容加密</strong></p><p>如果不使用 HTTPS 进行网络通信，也可以使用另一种方式。</p><p>客户端可以<strong>对 HTTP 报文进行加密处理后，再发送</strong>，这可以在一定程度上保证内容被窃听后，窃听者无法破解报文的信息。</p><h3 id="2、不验证通信方的身份，有可能会被伪装"><a href="#2、不验证通信方的身份，有可能会被伪装" class="headerlink" title="2、不验证通信方的身份，有可能会被伪装"></a>2、不验证通信方的身份，有可能会被伪装</h3><p>HTTP 协议中的请求和响应不会对通信方进行确认，任何人都可以发起请求，服务器只要接收到请求都会返回一个响应，因此可能存在以下几个隐患。</p><ul><li><strong>无法确定请求发送到目标服务器，有可能是伪装的服务器；</strong></li><li><strong>无法确定响应返回到的客户端，是真正发送请求的客户端，有肯能是伪装的客户端；</strong></li><li><strong>无法确定请求是谁发出的、来自何方；</strong></li></ul><h3 id="3、无法验证报文的完整性，可能已遭篡改"><a href="#3、无法验证报文的完整性，可能已遭篡改" class="headerlink" title="3、无法验证报文的完整性，可能已遭篡改"></a>3、无法验证报文的完整性，可能已遭篡改</h3><p> HTTP 无法证明通信报文的完整性、准确性。<strong>所以，在请求或响应发出后直到对方接收之前，这段时间内即使请求、响应被篡改了也无法获悉。</strong></p><p>为了防止以上出现的弊端，有必要使用 HTTPS。</p><p>HTTPS 与 HTTP 的区别是，<strong>HTTP 直接与 TCP 通信，HTTPS 是 HTTP 与 SSL 通信，SSL 再与 TCP 通信。</strong></p><p>在采用 SSL 后，HTTP 就拥有了<strong>加密、证书和完整性保护</strong>的功能。</p><h2 id="二、加密的两种方式"><a href="#二、加密的两种方式" class="headerlink" title="二、加密的两种方式"></a>二、加密的两种方式</h2><p><strong>加密分为对称加密和非对称加密。</strong></p><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>对称加密是指通信双方使用<strong>同一个密钥</strong>，使用加密算法和密钥对数据进行加密，使用机密使用同一密钥及相同算法的逆算法对密文进行解密。</p><p><strong>加密、解密都是用同一个密钥，因此被称为对称加密。</strong></p><p><strong>优点：</strong>加解密的效率高。<strong>缺点：</strong>不能直接在网络上传输密钥，一旦密钥泄漏，加密会被破解。</p><p>常见的对称加密算法：DES、AES。</p><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>非对称加密用<strong>两个密钥（公钥与私钥）进行加解密。</strong>使用公钥对数据进行加密，使用私钥对数据进行解密。</p><p><strong>优点：</strong>公钥可以在网络传输，安全性高。<strong>缺点：</strong>加密、解密花费的时间长、速度慢。</p><p><strong>HTTPS 采用的是混合加密机制。</strong></p><h3 id="HTTPS-的混合加密"><a href="#HTTPS-的混合加密" class="headerlink" title="HTTPS 的混合加密"></a>HTTPS 的混合加密</h3><p>HTTPS 采用<strong>对称加密和公钥加密</strong>二者结合的混合加密机制。</p><p>在交换密钥的过程使用<strong>公钥加密</strong>，在建立通信交换报文阶段<strong>使用对称加密。</strong></p><h2 id="三、HTTPS-的建立过程"><a href="#三、HTTPS-的建立过程" class="headerlink" title="三、HTTPS 的建立过程"></a>三、HTTPS 的建立过程</h2><ol><li>客户端发 Client Hello 报文开始 SSL 通信。报文中包含<strong>客户端支持的 SSL 版本</strong>，加密组件列表<strong>（加密算法及密钥长度）。</strong></li><li>服务端可进行 SSL 通信时，会以 Server Hello 报文作为回应。报文中包含<strong>SSL 版本以及加密组件。</strong>服务端的加密组件是从客户端的加密组件中筛选出来的。</li><li>服务器发送证书报文，包含<strong>公钥证书</strong>。</li><li>服务器发送 Server Hello Done 报文通知客户端，<strong>最初阶段的 SSL 握手协商部分结束。</strong></li><li>SSL 第一次握手结束后，客户端以 Client Key Exchange 报文作为回应。报文中包含<strong>Pre-master secret 的随机密码串，已用服务端的公钥加密。</strong></li><li>客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器，<strong>此后的通信会采用 Pre-master secret 密钥加密。</strong></li><li>客户端发送 Finished 报文。该报文包含<strong>至今全部报文的整体校验值</strong>。这次握手能否成功，还要看服务端是否能够正常解密。</li><li>服务端同样发送 Change Cipher Spec 报文。</li><li>服务端发送 Finished 报文。</li><li>服务端和客户端的 Finished 报文交换完毕后，<strong>SSL 连接就算建立完成。</strong> 通信会受到 SSL 保护，此后开始进行应用层协议通信，即发送 HTTP 请求。</li></ol><p><img src="https://img-blog.csdn.net/2018081021534690?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA5MTg0ODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>以上就是 HTTPS 的安全连接建立过程，以及与 HTTP 的区别。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何做到在子线程更新 UI？</title>
      <link href="/posts/thread_update_ui.html"/>
      <url>/posts/thread_update_ui.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>一般来讲，子线程是不能更新 UI 的，如果在子线程更新 UI，会报错。</p><p>但在某种情况下直接开启线程更新 UI 是不会报错的。</p><p>比如，在 onCreate 方法中，直接开启子线程更新 UI，这样是不会报错的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">override fun <span class="title">onCreate</span><span class="params">(savedInstanceState: Bundle?)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    setContentView(R.layout.activity_main)</span><br><span class="line">    textView = findViewById(R.id.tv)</span><br><span class="line">    thread &#123;</span><br><span class="line">        textView.text = <span class="string">"哈哈哈哈"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在子线程中假如延时，比如加一行<code>Thread.sleep(2000)</code>就会报错。</p><p>这是为什么呢？</p><p>有人会说，因为睡眠了 2 s，因此 UI 的线程检查机制就已经建立了，所以在子线程更新就会报错。</p><h2 id="更新-UI-的线程检测是什么时候开始的"><a href="#更新-UI-的线程检测是什么时候开始的" class="headerlink" title="更新 UI 的线程检测是什么时候开始的"></a>更新 UI 的线程检测是什么时候开始的</h2><p><img src="https://pic.downk.cc/item/5ebba4b3c2a9a83be51dfc07.jpg" alt="子线程更新 UI 的错误详情"></p><p>子线程更新的错误定位是 <code>ViewRootImpl</code> 中的 <code>checkThread</code> 方法和 <code>requestLayout</code> 方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ViewRootImpl 下 checkThread 的源码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mThread != Thread.currentThread()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CalledFromWrongThreadException(</span><br><span class="line">                <span class="string">"Only the original thread that created a view hierarchy can touch its views."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ViewRootImpl 下 requestLayout 的源码</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">        checkThread();</span><br><span class="line">        mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">        scheduleTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中可以看出，<code>checkThread</code> 就是进行线程检测的方法，而调用是在 <code>requestLayout</code> 方法中。</p><p>要想知道 <code>requestLayout</code> 是何时调用的，就要知道 <code>ViewRootImpl</code> 是如何创建的？</p><p><strong>因为在 <code>onCreate</code> 中创建子线程访问 UI，是不报错的，这也说明在 <code>onCreate</code> 中，<code>ViewRootImpl</code> 还未创建。</strong></p><h2 id="ViewRootImpl-是何时创建的。"><a href="#ViewRootImpl-是何时创建的。" class="headerlink" title="ViewRootImpl 是何时创建的。"></a>ViewRootImpl 是何时创建的。</h2><p>在 <code>ActivityThread</code> 的 <code>handleResumeActivity</code> 中调用了 <code>performResumeActivity</code> 进行 <code>onResume</code> 的回调。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finalStateRequest, <span class="keyword">boolean</span> isForward,String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 代码省略...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// performResumeActivity 最终会调用 Activity 的 onResume方法</span></span><br><span class="line">    <span class="comment">// 调用链如下： 会调用 r.activity.performResume。</span></span><br><span class="line">    <span class="comment">// performResumeActivity -&gt; r.activity.performResume -&gt; Instrumentation.callActivityOnResume(this) -&gt; activity.onResume();</span></span><br><span class="line">    <span class="keyword">final</span> ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 代码省略...</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (r.window == <span class="keyword">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">        r.activity.mVisibleFromServer = <span class="keyword">true</span>;</span><br><span class="line">        mNumVisibleActivities++;</span><br><span class="line">        <span class="keyword">if</span> (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">            <span class="comment">// 注意这句，让 activity 显示，并且会最终创建 ViewRootImpl</span></span><br><span class="line">            r.activity.makeVisible();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进一步跟进 <code>activity.makeVisible()</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeVisible</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mWindowAdded) &#123;</span><br><span class="line">        ViewManager wm = getWindowManager();</span><br><span class="line">        <span class="comment">// 往 WindowManager 中添加 DecorView</span></span><br><span class="line">        wm.addView(mDecor, getWindow().getAttributes());</span><br><span class="line">        mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mDecor.setVisibility(View.VISIBLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>WindowManager</code> 是一个接口，它的实现类是 <code>WindowManagerImpl</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WindowManagerImpl 的 addView 方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(@NonNull View view, @NonNull ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">    applyDefaultToken(params);</span><br><span class="line">    <span class="comment">// 最终调用了 WindowManagerGlobal 的 addView </span></span><br><span class="line">    mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WindowManagerGlobal 的 addView</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class="line"><span class="function"><span class="params">                    Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ViewRootImpl 对象的声明</span></span><br><span class="line">    ViewRootImpl root;</span><br><span class="line">    View panelParentView = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ViewRootImpl 对象的创建</span></span><br><span class="line">        root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line">        view.setLayoutParams(wparams);</span><br><span class="line">        mViews.add(view);</span><br><span class="line">        mRoots.add(root);</span><br><span class="line">        mParams.add(wparams);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用 ViewRootImpl 的 setView 方法</span></span><br><span class="line">            root.setView(view, wparams, panelParentView);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            <span class="comment">// BadTokenException or InvalidDisplayException, clean up.</span></span><br><span class="line">            <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                removeViewLocked(index, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可以看出，<code>ViewRootImpl</code> 是在 <code>activity</code> 的 <code>onResume</code> 方法调用后才由 <code>WindowManagerGlobal</code> 的 <code>addView</code> 方法创建。</p><h2 id="那-requestLayout-是如何调用的呢？"><a href="#那-requestLayout-是如何调用的呢？" class="headerlink" title="那 requestLayout 是如何调用的呢？"></a>那 <code>requestLayout</code> 是如何调用的呢？</h2><p>在上面 <code>WindowManagerGlobal</code> 的 <code>addView</code> 方法中，创建完 <code>ViewRootImpl</code> 后，会调用它的 <code>setView</code> 的方法，在 <code>setView</code> 方法内部会调用 <code>requestLayout</code>。</p><p>此时就会去检测 UI 更新时调用的线程了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ViewRootImpl 的 setView</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mView == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mView = view;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 省略无关代码...</span></span><br><span class="line">            <span class="comment">// requestLayout 的调用</span></span><br><span class="line">            requestLayout();</span><br><span class="line">        </span><br><span class="line">          <span class="comment">// 省略无关代码...</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// requestLayout 方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">        checkThread();</span><br><span class="line">        mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">        scheduleTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在 <code>SheduleTranversals</code> 方法中，会调用 <code>TraversalRunnable</code> 的 <code>run</code>方法，最终会在 <code>performTraversals</code> 方法中，调用 <code>performMeasure</code> <code>performLayout</code> <code>performDraw</code> 去开始 View 的绘制流程。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        <span class="comment">// TraversalRunnable 的 run 方法中，会开启 UI 的measure、layout、draw</span></span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">            Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">       <span class="comment">// 省略无关代码...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doTraversal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">        <span class="comment">// 省略部分代码</span></span><br><span class="line">        performTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Ask host how big it wants to be</span></span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">    performLayout(lp, mWidth, mHeight);</span><br><span class="line">    performDraw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="子线程更新-UI-实战"><a href="#子线程更新-UI-实战" class="headerlink" title="子线程更新 UI 实战"></a>子线程更新 UI 实战</h2><p>既然知道了子线程更新 UI 的检测是在 <code>checkThread</code> 方法中，那么有没有什么方法可以绕过呢？能否做到子线程更新 UI 呢？</p><p>答案是可以的。</p><p>我以一个简单的 demo 实验一下，下面先看效果。</p><p><img src="https://pic.downk.cc/item/5ebb9b5dc2a9a83be5155f05.gif" alt=""></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MainActivity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> View containerView;</span><br><span class="line">    <span class="keyword">private</span> ViewTreeObserver.OnGlobalLayoutListener globalLayoutListener;</span><br><span class="line">    <span class="keyword">private</span> TextView mTv2;</span><br><span class="line">    <span class="keyword">private</span> TextView mTv1;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        containerView = findViewById(R.id.container_layout);</span><br><span class="line">        mTv1 = findViewById(R.id.text);</span><br><span class="line">        mTv2 = findViewById(R.id.text2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启线程，启动 GlobalLayoutListener</span></span><br><span class="line">        Executors.newSingleThreadExecutor().execute(() -&gt; initGlobalLayoutListener());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initGlobalLayoutListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        globalLayoutListener = () -&gt; &#123;</span><br><span class="line">            Log.e(<span class="string">"caihua"</span>, <span class="string">"onGlobalLayout : "</span> + Thread.currentThread().getName());</span><br><span class="line">            ViewGroup.LayoutParams layoutParams = containerView.getLayoutParams();</span><br><span class="line">            containerView.setLayoutParams(layoutParams);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">this</span>.getWindow().getDecorView().getViewTreeObserver().addOnGlobalLayoutListener(globalLayoutListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUiInMain</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        mTv1.setText(<span class="string">"主线程更新 UI"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUiInThread</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                SystemClock.sleep(<span class="number">2000</span>);</span><br><span class="line">                mTv2.setText(<span class="string">"子线程更新 UI ："</span> + Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理：通过 <code>ViewTreeObserver.OnGlobalLayoutListener</code> 设置全局的布局监听，然后在 <code>onGlobalLayout</code> 方法中，调用 <code>view</code> 的 <code>setLayoutParams</code> 方法，<code>setLayoutParams</code> 方法内部会调用 <code>requestLayout</code>，这样就可以绕过线程检测。</p><p>为什么能绕过呢？</p><p><strong>因为 <code>setLayoutParams</code> 中调用的 <code>requestLayout</code> 方法并不是 <code>ViewRootImpl</code> 中 <code>requestLayout</code>.</strong></p><p><strong>而 <code>View</code> 的 <code>requestLayout</code> 并不调用 <code>checkThread</code> 方法去检测线程。</strong></p><p>源码如下↓</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// view.setLayoutParams 源码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLayoutParams</span><span class="params">(ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (params == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Layout parameters cannot be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mLayoutParams = params;</span><br><span class="line">    resolveLayoutParams();</span><br><span class="line">    <span class="keyword">if</span> (mParent <span class="keyword">instanceof</span> ViewGroup) &#123;</span><br><span class="line">        ((ViewGroup) mParent).onSetLayoutParams(<span class="keyword">this</span>, params);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用 requestLayout 方法。</span></span><br><span class="line">    requestLayout();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// View 的 requestLayout 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mMeasureCache != <span class="keyword">null</span>) mMeasureCache.clear();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAttachInfo != <span class="keyword">null</span> &amp;&amp; mAttachInfo.mViewRequestingLayout == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ViewRootImpl viewRoot = getViewRootImpl();</span><br><span class="line">        <span class="keyword">if</span> (viewRoot != <span class="keyword">null</span> &amp;&amp; viewRoot.isInLayout()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!viewRoot.requestLayoutDuringLayout(<span class="keyword">this</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mAttachInfo.mViewRequestingLayout = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mPrivateFlags |= PFLAG_FORCE_LAYOUT;</span><br><span class="line">    mPrivateFlags |= PFLAG_INVALIDATED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mParent != <span class="keyword">null</span> &amp;&amp; !mParent.isLayoutRequested()) &#123;</span><br><span class="line">        mParent.requestLayout();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mAttachInfo != <span class="keyword">null</span> &amp;&amp; mAttachInfo.mViewRequestingLayout == <span class="keyword">this</span>) &#123;</span><br><span class="line">        mAttachInfo.mViewRequestingLayout = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap原理解析</title>
      <link href="/posts/HashMap_Analysis.html"/>
      <url>/posts/HashMap_Analysis.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>HashMap 是我们使用频率最高的集合之一。它是用于映射(键值对)处理的数据类型。随着 JDK 版本的更新，JDK1.8 对 HashMap 底层的实现进行了优化，例如引入红黑树的数据结构。</p><p>本文将深入探讨 HashMap 的结构实现和功能原理。</p><h2 id="基本特点"><a href="#基本特点" class="headerlink" title="基本特点"></a>基本特点</h2><p>HashMap 你应该也很熟悉。我在这就简单说一下它的基本特点，</p><ul><li>HashMap是基于哈希表的 Map 接口的实现。</li><li>允许 null 键和 null 值，最多只允许一条记录的键为 null，允许多条记录的值为 null。</li><li>不保证映射的顺序。特别是，<strong>它不能保证顺序会随着时间的推移保持恒定</strong>。</li><li>HashMap 根据键的 hashCode 值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度 O(1)。</li></ul><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>从结构实现来讲，HashMap 是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的。</p><p><img src="../img/hashmap/map_data_structure.png" alt=""></p><h3 id="HashMap-数据底层具体存储的是什么？"><a href="#HashMap-数据底层具体存储的是什么？" class="headerlink" title="HashMap 数据底层具体存储的是什么？"></a>HashMap 数据底层具体存储的是什么？</h3><p>通过查看 HashMap 的源码，它其中有一个非常重要的字段 <code>Node&lt;K,V&gt;[] table</code>，即哈希桶数组，是一个Node 的数组。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;<span class="comment">// 用来定位数组索引位置</span></span><br><span class="line">        <span class="keyword">final</span> K key; <span class="comment">// 用来存储的 key</span></span><br><span class="line">        V value; <span class="comment">// 存储的 value</span></span><br><span class="line">        Node&lt;K,V&gt; next;<span class="comment">// 链表的下一个元素</span></span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123;...&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123;...&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;...&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Node 是 HashMap 中的一个内部类，实现了 Map.Entry 接口，本质是就是一个映射(键值对)。</p><p>我们在 HashMap 中存储的每一个值，都是一个 Node。</p><h3 id="Map-为什么要用数组-单链表的方式？"><a href="#Map-为什么要用数组-单链表的方式？" class="headerlink" title="Map 为什么要用数组+单链表的方式？"></a>Map 为什么要用数组+单链表的方式？</h3><p>任何哈希函数基本都无法彻底避免碰撞，常见的解决碰撞的方法有以下几种：</p><ul><li><p>开放寻址法：如果出现了散列冲突，就重新探测一个空闲位置，将其插入。</p></li><li><p>链表法：就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被 Hash 后，得到数组下标，把数据放在对应下标元素的链表上。</p></li><li><p>再哈希法：当哈希地址发生冲突用其他的函数计算另一个哈希函数地址，直到冲突不再产生为止。</p></li><li><p>建立公共溢出区：将哈希表分为基本表和溢出表两部分，发生冲突的元素都放入溢出表中。</p></li></ul><p>HashMap 采用的就是<strong>链表法</strong>这种方式。 但即使负载因子和 Hash 算法设计的再合理，也免不了会出现拉链过长的情况，<strong>一旦出现拉链过长，则会严重影响 HashMap 的性能。</strong></p><p>于是，在 JDK1.8 版本中，HashMap 做了进一步的优化，引入了红黑树。当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高 HashMap 的性能。</p><h4 id="为什么转成红黑树就能提高性能呢？"><a href="#为什么转成红黑树就能提高性能呢？" class="headerlink" title="为什么转成红黑树就能提高性能呢？"></a>为什么转成红黑树就能提高性能呢？</h4><p>虽然链表的删除和插入的速度很快，但是查找的速度很慢，需要从头遍历整个链表，时间复杂度为 O(n)，删除和插入的前提是<strong>首先要找到整个元素</strong>，因此也会受到链表长度的影响。当链表过长时，增删改查速度就会降低。</p><p>红黑树是一种平衡二叉树，它的增删改查的时间复杂度是 O(logn)。</p><h2 id="HashMap-的成员变量"><a href="#HashMap-的成员变量" class="headerlink" title="HashMap 的成员变量"></a>HashMap 的成员变量</h2><p>HashMap 中的成员变量，除了一些常量外，主要有以下几个。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> size; <span class="comment">// 集合大小</span></span><br><span class="line"><span class="keyword">int</span> modCount; <span class="comment">// 内部发生变化的次数</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor; <span class="comment">// 负载因子</span></span><br><span class="line"><span class="keyword">int</span> threshold; <span class="comment">// 阈值</span></span><br></pre></td></tr></table></figure><p>size 比较简单，就是 HashMap 中包含的映射的总数。</p><p>modCount，主要用来记录 HashMap 内部结构发生变化的次数，主要用于迭代的快速失败。强调一点，<strong>内部结构发生变化指的是结构发生变化</strong>，例如 put 新键值对，但是某个 key 对应的 value 值被覆盖不属于结构变化。</p><p>loadFactor 负载因子，默认值是0.75，负载因子越大，说明 Map 中的元素越多，空闲位置越少，散列冲突的概率就越大。</p><p>threshold 阈值，是 HashMap 所能容纳的最大数据量的 Node (键值对)个数。</p><p>算法公式为：<code>threshold = length * loadFactor</code>。其中 length 是 Node[] table 的长度(默认 16)。</p><p>threshold 就是在此 loadFactor 和 length 对应下允许的最大元素数目，超过这个数目就重新 resize (扩容)，扩容后的 HashMap 容量是之前容量的两倍。</p><h2 id="确定数组索引位置的-hash-算法"><a href="#确定数组索引位置的-hash-算法" class="headerlink" title="确定数组索引位置的 hash 算法"></a>确定数组索引位置的 hash 算法</h2><p>不管是添加、删除还是查找，<strong>第一步首先是要确定当前元素在 HashMap 中的位置。</strong></p><p>HashMap 中的 hash 采用的是<strong>取 key 的 hashCode 值，然后进行高位运算，再进行取模运算。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> h;</span><br><span class="line">      <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="为什么要采用这种算法呢？"><a href="#为什么要采用这种算法呢？" class="headerlink" title="为什么要采用这种算法呢？"></a>为什么要采用这种算法呢？</h3><p>我们知道，在 HashMap 中采用 hash 为 key，因此我们要尽量避免 hash 碰撞。</p><p>上面的代码中，<code>key.hashCode()</code>函数调用的是 key 键值类型自带的哈希函数，返回 int 型的值。</p><p>int 值的取值范围在 <code>-2^31 ~ 2^31 - 1</code> 之间，大约有 40 亿的空间，如果直接拿散列表的值做数组的所含，虽然很难出现碰撞，但是 40 亿的长度实在是太大了，不太现实。</p><p>因此需要对得到的散列值进行进一步的操作处理。</p><p>java 8 采用 key.hashCode() 与 hash 值的高 16 位进行异或运算。</p><blockquote><p>异或：如果a、b两个值不相同，则异或结果为1。 如果a、b两个值相同，异或结果为0。</p></blockquote><p>为什么这里需要将高位数据移位到低位进行异或运算呢？</p><p>这是因为有些数据计算出的哈希值差异<strong>主要在高位</strong>，利用高半区和低半区做异或，就是为了<strong>混合原始哈希码的高位和低位，以此来加大低位的随机性</strong>。混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来，可以有效避免类似情况下的哈希碰撞。</p><p><img src="../img/hashmap/jisuan_hash.png" alt=""></p><h2 id="存储数据的-put-方法"><a href="#存储数据的-put-方法" class="headerlink" title="存储数据的 put 方法"></a>存储数据的 put 方法</h2><p>HashMap 的 put 方法主要分为以下几步：</p><p>①. 判断键值对数组 table[i] 是否为空或为 null，否则执行 resize() 进行扩容；</p><p>②. 根据键值 key 计算 hash 值得到插入的数组索引 i，如果 table[i]==null，直接新建节点添加，转向 ⑥，如果 table[i] 不为空，转向③；</p><p>③. 判断 table[i] 的首个元素是否和 key 一样，如果相同直接覆盖 value，否则转向④，这里的相同指的是 hashCode 以及 equals；</p><p>④. 判断 table[i] 是否为 TreeNode，即 table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；</p><p>⑤. 遍历 table[i]，判断链表长度是否大于 8，大于 8 的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现 key 已经存在直接覆盖 value 即可；</p><p>⑥. 插入成功后，判断实际存在的键值对数量 size 是否超多了最大容量 threshold，如果超过，进行扩容。</p><p>JDK1.8HashMap的put方法源码如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对key的hashCode()做hash</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K, V&gt;[] tab;</span><br><span class="line">    Node&lt;K, V&gt; p;</span><br><span class="line">    <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 步骤①：tab为空则创建</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 步骤②：计算index，并对null做处理 </span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K, V&gt; e;</span><br><span class="line">        K k;</span><br><span class="line">        <span class="comment">// 步骤③：节点key存在，直接覆盖value</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">            <span class="comment">// 步骤④：判断该链为红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K, V&gt;) p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="comment">// 步骤⑤：该链为链表</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    链表长度大于<span class="number">8</span>转换为红黑树进行处理</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st  </span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                key已经存在直接覆盖value</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 步骤⑥：超过最大容量 就扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 put 时，会通过 <code>(n-1) &amp; hash</code> 来计算当前元素的坐标索引。</p><hr><h4 id="番外：-为什么用-amp-操作呢？"><a href="#番外：-为什么用-amp-操作呢？" class="headerlink" title="番外： 为什么用 &amp; 操作呢？"></a>番外： 为什么用 &amp; 操作呢？</h4><p>主要是用来取模。</p><p><strong>位运算（&amp;）效率要比取模运算（%）高很多，主要原因是位运算直接对内存数据进行操作，不需要转成十进制，因此处理速度非常快。</strong></p><h4 id="为什么可以使用位运算-amp-来实现取模运算-呢"><a href="#为什么可以使用位运算-amp-来实现取模运算-呢" class="headerlink" title="为什么可以使用位运算(&amp;)来实现取模运算(%)呢"></a>为什么可以使用位运算(&amp;)来实现取模运算(%)呢</h4><p>原理如下：</p><blockquote><p>X % 2^n = X &amp; (2^n – 1)</p><p>2^n 表示 2 的 n 次方，也就是说，一个数对 2^n 取模 == 一个数和 (2^n – 1) 做按位与运算 。</p><p>假设 n 为3，则 2^3 = 8，表示成 2 进制就是 1000。2^3 -1 = 7 ，即 0111。</p><p>此时 X &amp; (2^3 – 1) 就相当于取 X 的 2 进制的最后三位数。</p><p>从 2 进制角度来看，X / 8相当于 X &gt;&gt; 3，即把 X 右移 3 位，此时得到了 X / 8 的商，而被移掉的部分(后三位)，则是X % 8，也就是余数。</p></blockquote><p>简单来讲就是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 % 8 &#x3D; 6 ，6 &amp; 7 &#x3D; 6；</span><br><span class="line">10 &amp; 8 &#x3D; 2 ，10 &amp; 7 &#x3D; 2</span><br></pre></td></tr></table></figure><p>记住会用就行。</p><hr><p>具体的 put 过程可以参照下图进行理解。</p><p><img src="../img/hashmap/hashmap_put.png" alt="HashMap 的 put 流程"></p><h2 id="HashMap-的扩容机制"><a href="#HashMap-的扩容机制" class="headerlink" title="HashMap 的扩容机制"></a>HashMap 的扩容机制</h2><p>扩容(resize)就是重新计算容量。</p><p>当我们不停的向 HashMap 中添加元素，当达到临界值，HashMap 无法添加新元素时，就需要进行扩容，以便能装入更多的元素。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table; <span class="comment">// 新建变量扩容前的 Entry Node</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length; <span class="comment">//扩容前数组的长度</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold; <span class="comment">// 扩容前能容纳最大键值对数量</span></span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123; </span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                  oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的 resize 上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 将之前的元素都移动到新的 buckets 中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 暂时忽略红黑树部分</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 链表优化重 hash 的代码块</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                         <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;  <span class="comment">//仅仅是判断元素是否需要换位置，不要理解为元素的新位置</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                     <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在经过 resize 扩容后，数组的长度会扩大为原来的 2 倍，所以，<strong>元素的位置要么是在原位置，要么是在原位置再移动 2 次幂的位置</strong>。</p><p>结合下图理解，n 为 table 的长度，图（a）表示扩容前的 key1 和 key2 两种 key 确定索引位置的示例，图（b）表示扩容后 key1 和 key2 两种 key 确定索引位置的示例，其中 hash1 是 key1 对应的哈希与高位运算结果。</p><p><img src="../img/resize_hash1.png" alt=""></p><p>元素在重新计算 hash 之后，因为 n 变为 2 倍，那么 n-1 的范围在高位多 1bit(红色)，因此新的 index 就会发生这样的变化。</p><p><img src="../img/hashmap/element_index_change.png" alt="元素位置的变化"></p><p>因此，扩容时，只需要看看原来的 hash 值新增的那个 bit 是 1 还是 0 就行了，是 0 的话索引没变，是 1 的话索引变成“原索引 + oldCap”，可以结合下图理解，下图是 16 -&gt; 32 的过程。</p><p><img src="../img/hashmap/resize_syt.png" alt="扩容示意图"></p><p>这个设计确实非常的巧妙，既省去了重新计算 hash 值的时间，而且同时，由于新增的 1bit 是 0 还是 1 可以认为是随机的，因此 resize 的过程，均匀的把之前的冲突的节点分散到新的 bucket 了。</p><p>HashMap 的 get 方法比较简单，在这里就不再进行分析了。</p><h2 id="为什么HashMap线程不安全"><a href="#为什么HashMap线程不安全" class="headerlink" title="为什么HashMap线程不安全?"></a>为什么HashMap线程不安全?</h2><p>1.多线程 put，导致的数据不一致。</p><p>当拥有多个线程时，每个线程都会去抢占 CPU 资源，而 CPU 根据一定的线程调度算法来切换线程，因此就可能出现线程 A 没执行完毕，线程 B 就拿到 CPU 资源去执行了，从而会导致数据错乱。</p><p>比如有两个线程 A 和 B。</p><p>A 希望插入一个 key-value 到 HashMap 中，在完成了计算索引坐标，获取链表头结点的操作后，线程 A 的时间用完了；</p><p>B 开始执行，B 计算完毕，成功将记录插入到了 HashMap 中；</p><p>此时，A 再次被执行，假设 A、B 计算出的索引是一致的，由于 A 不知道 B 已经插入到此节点了，因此 A 进行插入事，就会覆盖 B 的记录，就造成了数据不一致的行为。</p><p>2.resize 造成的无限循环</p><p>HashMap 在 resize 时，会重新计算元素的位置与 hash。</p><p>因此在多线程操作 HashMap 时，可能会出现node 的 next 指向的下一个元素之间，形成环形链表，导致无限循环。</p><p><img src="../img/hashmap/hashmap_dead_loop.png" alt="image"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://tech.meituan.com/2016/06/24/java-hashmap.html" target="_blank" rel="noopener">https://tech.meituan.com/2016/06/24/java-hashmap.html</a></li><li><a href="https://www.hollischuang.com/archives/2091" target="_blank" rel="noopener">https://www.hollischuang.com/archives/2091</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 协议完全解析</title>
      <link href="/posts/http_analysis.html"/>
      <url>/posts/http_analysis.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>HTTP 的全称是 HyperText Transfer Protocol (超文本传输协议)的缩写，是一种建立在 TCP 上的无状态连接。HTTP 是互联网的<strong>基础协议</strong>，用于客户端与服务器之间的通信，它规定了客户端和服务器之间的<strong>通信格式</strong>，包括请求与响应的格式。<br> <a id="more"></a></p><p>基本的工作流程是客户端发送一个 HTTP 请求，服务端收到请求开始处理，处理结束返回给客户端结果，客户端对结果进行处理并展示。</p><p>现在最流行的 HTTP 版本还是 1997 年发布的 HTTP/1.1。<br><img src="https://ww1.sinaimg.cn/large/007i4MEmgy1fyuos2jbzvj30fb051t90.jpg" alt=""></p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>HTTP 的工作方式</li><li>HTTP 的报文格式</li><li>HTTP 起始行</li><li>HTTP 请求方法</li><li>HTTP 响应码</li><li>HTTP Headers<h2 id="一、-HTTP-的工作方式"><a href="#一、-HTTP-的工作方式" class="headerlink" title="一、 HTTP 的工作方式"></a>一、 HTTP 的工作方式</h2><h3 id="1-1-请求过程"><a href="#1-1-请求过程" class="headerlink" title="1.1 请求过程"></a>1.1 请求过程</h3>客户端向服务端发送一段请求报文，服务端收到后，返回响应报文，客户端对响应内容进行展示。</li></ul><img src = "https://ww1.sinaimg.cn/large/007i4MEmgy1fyvp5x2xupj317g0nmdjm.jpg" width = 80%/><p>一个 HTTP 的请求必定是<strong>由客户端发起，服务器端回复响应</strong>。服务器在没有接收到请求之前不会发送响应。</p><blockquote><p>名词解释</p><p>客户端：请求访问文本或图像等资源的一端。</p><p>服务端：提供资源响应的一端。</p><p>资源：网络上的一切内容都是资源，无论是图片文字还是动态代码。</p></blockquote><h3 id="1-2-请求方式"><a href="#1-2-请求方式" class="headerlink" title="1.2 请求方式"></a>1.2 请求方式</h3><h4 id="web-浏览器请求："><a href="#web-浏览器请求：" class="headerlink" title="web 浏览器请求："></a>web 浏览器请求：</h4><img src="https://ww1.sinaimg.cn/large/007i4MEmgy1fyvq039dv9j30gt048gn8.jpg" width = 20% height = 20% /><p>请求过程如下 ⬇️</p><ol><li>用户输入地址后回车或点击链接</li><li>浏览器拼装 HTTP 报文并发送请求给服务器 </li><li>服务器处理请求后，发送响应报文给浏览器 </li><li>浏览器解析响应报文并使用渲染引擎显示到界面</li></ol><h4 id="APP-客户端请求："><a href="#APP-客户端请求：" class="headerlink" title="APP 客户端请求："></a>APP 客户端请求：</h4><img src="https://ww1.sinaimg.cn/large/007i4MEmgy1fyvq1pw7d9j30u009utas.jpg" width = 40% height = 40% /><p>请求过程如下 ⬇️</p><ol><li>用户点击或界面自动触发联网需求</li><li>Android 代码调用拼装 HTTP 报文并发送请求到服务器</li><li>服务器处理请求后发送响应报文给手机</li><li>Android 代码处理响应报文并作出相应处理(如储存数据、加工数据、显示数据到界面)</li></ol><h3 id="1-3-报文是什么"><a href="#1-3-报文是什么" class="headerlink" title="1.3 报文是什么"></a>1.3 报文是什么</h3><p>报文是在 HTTP 应用程序之间发送的<strong>数据块</strong>。这些数据块以一些文本的元信息 (meta 标签中的信息) 开头，描述了报文的内容及含义。</p><p>每条报文都包含<strong>一条来自于客户端的请求，或者一条来自于服务端的响应</strong>。</p><p>它由 3 部分组成：对报文进行描述的「<strong>起始行</strong>」、包含属性的「<strong>首部(Header)</strong>」以及可选的、包含数据的「<strong>主体(body)</strong>」</p><p><img src="https://ww1.sinaimg.cn/large/007i4MEmgy1fz1ph978fpj30nh0anwfy.jpg" alt=""></p><h2 id="二、HTTP-的报文格式"><a href="#二、HTTP-的报文格式" class="headerlink" title="二、HTTP 的报文格式"></a>二、HTTP 的报文格式</h2><h3 id="2-1-请求报文的格式"><a href="#2-1-请求报文的格式" class="headerlink" title="2.1 请求报文的格式"></a>2.1 请求报文的格式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;method&gt; &lt;path&gt; &lt;HTTP version&gt;</span><br><span class="line">&lt;headers&gt;</span><br><span class="line"></span><br><span class="line">&lt;entity-body&gt;</span><br></pre></td></tr></table></figure><h3 id="2-2-响应报文的格式"><a href="#2-2-响应报文的格式" class="headerlink" title="2.2 响应报文的格式"></a>2.2 响应报文的格式</h3><p>(注意，<strong>只有起始行的语法与请求报文有所不同</strong>)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;HTTP version&gt; &lt;status code&gt; &lt;reason-phrase&gt;</span><br><span class="line">&lt;headers&gt;</span><br><span class="line"></span><br><span class="line">&lt;entity-body&gt;</span><br></pre></td></tr></table></figure><p>下面是对各部分的简要描述，后面会详细介绍。</p><ul><li>方法 (method)<br>客户端希望服务器对资源执行的动作，常见的方法有 Get、Post、HEAD 等。</li><li>请求路径 (path)<br>请求的 URL 描述了要对哪个资源执行这个方法，是给服务器看的。</li><li>HTTP 版本(HTTP version)  </li><li>状态码(status code)<br>不同状态码对应不同的响应状态</li><li>原因短句(reason-phrase)<br>对状态码进行简单的描述。</li><li>首部(headers)<br>包含许多键值对，是对响应数据的一些格式信息。</li></ul><h2 id="三、-Method-请求方法"><a href="#三、-Method-请求方法" class="headerlink" title="三、 Method(请求方法)"></a>三、 Method(请求方法)</h2><p>最常见的请求方法就是 <code>GET</code> 和 <code>POST</code>了。除此之外还有 <code>PUT</code>、<code>DELETE</code>、<code>HEAD</code> 等。</p><h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><ul><li>最常见的请求方式</li><li>指定请求路径，向服务器请求资源</li><li>只获取资源，不对服务器数据进行修改</li><li>不发送 body</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET  &#x2F;users&#x2F;1  HTTP&#x2F;1.1</span><br><span class="line">Host: api.github.com</span><br></pre></td></tr></table></figure><p>对应的 Retrofit 的代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GET(&quot;&#x2F;users&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">Call&lt;User&gt; getUser(@Path(&quot;id&quot;) String id, @Query(&quot;gender&quot;) String gender);</span><br></pre></td></tr></table></figure><h3 id="Post"><a href="#Post" class="headerlink" title="Post"></a>Post</h3><ul><li>用户增加或者修改资源</li><li>包含 body，发送给服务器的内容写在 body 里面</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST  &#x2F;users  HTTP&#x2F;1.1</span><br><span class="line">Host: api.github.com</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 13</span><br></pre></td></tr></table></figure><p>对应的 Retrofit 的代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@FormUrlEncoded</span><br><span class="line">@POST(&quot;&#x2F;users&quot;)</span><br><span class="line">Call&lt;User&gt; addUser(@Field(&quot;name&quot;) String name, @Field(&quot;gender&quot;) String</span><br><span class="line">gender);</span><br></pre></td></tr></table></figure><h3 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h3><ul><li>用于修改资源</li><li>包含 body，发送给服务器的内容写在 body 里面</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT  &#x2F;users&#x2F;1  HTTP&#x2F;1.1</span><br><span class="line">Host: api.github.com</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 13</span><br></pre></td></tr></table></figure><p>对应的 Retrofit 的代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@FormUrlEncoded</span><br><span class="line">@PUT(&quot;&#x2F;users&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">Call&lt;User&gt; updateGender(@Path(&quot;id&quot;) String id, @Field(&quot;gender&quot;) String</span><br><span class="line">gender);</span><br></pre></td></tr></table></figure><h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><ul><li>用于删除资源</li><li>不发送 body</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE  &#x2F;users&#x2F;1  HTTP&#x2F;1.1</span><br><span class="line">Host: api.github.com</span><br></pre></td></tr></table></figure><p>对应的 Retrofit 的代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@DELETE(&quot;&#x2F;users&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">Call&lt;User&gt; getUser(@Path(&quot;id&quot;) String id, @Query(&quot;gender&quot;) String gender);</span><br></pre></td></tr></table></figure><h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><ul><li><code>HEAD</code> 与 <code>GET</code> 的使用方式完全相同。</li><li>区别在于，<code>HEAD</code> 请求的返回响应中没有 <code>Body</code></li><li>用途：比如下载需求，返回的 Headers 中有下载内容的大小，可以用于显示进度。</li></ul><h3 id="小知识点"><a href="#小知识点" class="headerlink" title="小知识点"></a>小知识点</h3><p><code>GET</code>、<code>PUT</code>、<code>DELETE</code> 都是<strong>幂等</strong>操作，就是说，请求一次和请求多次的结果是一样的。<br>比如，GET 请求一个数据，请求一次和请求十次返回的结果是一样的，PUT 同样修改一个数据，修改一次和修改十次，结果也都是一样的。</p><h2 id="四、状态码-status-code"><a href="#四、状态码-status-code" class="headerlink" title="四、状态码(status code)"></a>四、状态码(status code)</h2><p>状态码是对结果进行类型化的描述的，比如「请求成功」、「内容未找到」等<br>主要分为 5 类。</p><h3 id="1xx：临时性消息。"><a href="#1xx：临时性消息。" class="headerlink" title="1xx：临时性消息。"></a>1xx：临时性消息。</h3>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">100：继续发送</span><br><span class="line">101：正在切换协议</span><br></pre></td></tr></table></figure><h3 id="2xx：成功。"><a href="#2xx：成功。" class="headerlink" title="2xx：成功。"></a>2xx：成功。</h3>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">200：OK (最常见) </span><br><span class="line">201：创建成功</span><br></pre></td></tr></table></figure><h3 id="3xx：重定向。"><a href="#3xx：重定向。" class="headerlink" title="3xx：重定向。"></a>3xx：重定向。</h3>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">301：域名永久移动</span><br><span class="line">302：暂时移动</span><br><span class="line">304：内容未改变，请求被重定向到客户端本地缓存</span><br></pre></td></tr></table></figure><h3 id="4xx：客户端错误"><a href="#4xx：客户端错误" class="headerlink" title="4xx：客户端错误"></a>4xx：客户端错误</h3>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">400：客户端请求错误，服务器不理解请求的语法。</span><br><span class="line">401：未授权，要求进行身份验证。</span><br><span class="line">403：被禁止，服务器拒绝请求。</span><br><span class="line">404：找不到内容，服务器找不到请求的网页。(最常见)</span><br></pre></td></tr></table></figure><h3 id="5xx：服务器错误"><a href="#5xx：服务器错误" class="headerlink" title="5xx：服务器错误"></a>5xx：服务器错误</h3>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">500：服务器内部错误 (最常见)</span><br><span class="line">503：服务不可用</span><br></pre></td></tr></table></figure><h2 id="五、首部-Headers"><a href="#五、首部-Headers" class="headerlink" title="五、首部(Headers)"></a>五、首部(Headers)</h2><p>首部包含多个请求头，是用来描述消息的元数据(meta data)。</p><p>首部字段有很多，主要分为以下几类：</p><ul><li>通用首部 =&gt; 提供了与报文相关的最基本的信息</li><li>请求首部 =&gt; 只在请求报文中有意义的首部</li><li>响应首部 =&gt; 只在响应报文中有意义的首部</li><li>body 首部 =&gt; 描述 body 的首部</li></ul><p>下面我们就说一些比较常用的。</p><h3 id="5-1-通用首部"><a href="#5-1-通用首部" class="headerlink" title="5.1 通用首部"></a>5.1 通用首部</h3><h4 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h4><p>提供日期和时间标志，说明报文是在什么时间创建的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Date: Tue, 12 Feb 2019 07:32:07 GMT</span><br></pre></td></tr></table></figure><h4 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h4><p>允许客户端和服务器指定与请求/响应连接有关的选项。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure><h4 id="其他通用首部"><a href="#其他通用首部" class="headerlink" title="其他通用首部"></a>其他通用首部</h4><p><strong>Via</strong> : 显示报文经过的中间节点（代理、网关）。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">via: cache25.l2ot7-1[0,304-0,H], cache25.l2ot7-1[1,0], cache5.us14[342,200-0,H]</span><br></pre></td></tr></table></figure><p><strong>Transfer-Encoding</strong> : 告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Transfer-Encoding: chunked</span><br></pre></td></tr></table></figure><p><strong>Cache-Control</strong> : 指定缓存的控制方式。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cache-control: no-store, no-cache, must-revalidate, proxy-revalidate</span><br></pre></td></tr></table></figure><h3 id="5-2-请求首部"><a href="#5-2-请求首部" class="headerlink" title="5.2 请求首部"></a>5.2 请求首部</h3><h4 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h4><p>给出了接收请求的服务器的主机名和端口。(注意:不是在网络上用于寻址的，⽽是在目标服务器上定位子服务器。)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Host: api.github.com</span><br></pre></td></tr></table></figure><h4 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h4><p>用来告诉<strong>服务端</strong>客户端会接受的媒体类型，包括客户端需要什么，可以使用什么，以及不想要什么。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8</span><br><span class="line"></span><br><span class="line">&#39;*&#39; 用来表示通配符。</span><br><span class="line">;q&#x3D; (q-factor weighting)</span><br><span class="line">值代表优先顺序，用相对质量价值表示，又称为权重。</span><br></pre></td></tr></table></figure><h4 id="Accept-Charset"><a href="#Accept-Charset" class="headerlink" title="Accept-Charset"></a>Accept-Charset</h4><p>用来告知服务器，客户端可以处理的字符集类型。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accept-Charset: utf-8, iso-8859-1;q&#x3D;0.5</span><br></pre></td></tr></table></figure><h4 id="Accept-Encoding"><a href="#Accept-Encoding" class="headerlink" title="Accept-Encoding"></a>Accept-Encoding</h4><p>用来将客户端能够理解的内容编码方式告知服务器，服务端会选择一个客户端提议的方式。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line"></span><br><span class="line">gzip：表示采用 Lempel-Ziv coding (LZ77) 压缩算法，以及32位CRC校验的编码方式。</span><br><span class="line">compress：采用 Lempel-Ziv-Welch (LZW) 压缩算法。</span><br><span class="line">deflate：采用 zlib 结构和 deflate 压缩算法。</span><br><span class="line">br：表示采用 Brotli 算法的编码方式。</span><br><span class="line">identity：用于指代自身（例如：未经过压缩和修改）。除非特别指明，这个标记始终可以被接受。</span><br></pre></td></tr></table></figure><h4 id="Accept-Language"><a href="#Accept-Language" class="headerlink" title="Accept-Language"></a>Accept-Language</h4><p>用来告诉服务器，客户端能够理解<strong>哪些语言</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9,en;q&#x3D;0.8</span><br></pre></td></tr></table></figure><h4 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h4><p>告诉服务器，客户端要获取哪段数据。<br>主要用于：<strong>断点续传</strong>、<strong>多线程下载</strong>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">Range: &lt;unit&gt;&#x3D;&lt;range-start&gt;-&lt;range-end&gt;, &lt;range-start&gt;-&lt;range-end&gt;, &lt;range-start&gt;-&lt;range-end&gt;</span><br><span class="line">&lt;unit&gt;：范围所采用的单位，通常是字节（bytes）。</span><br><span class="line">&lt;range-start&gt;：一个整数，表示在特定单位下，范围的起始值。</span><br><span class="line">&lt;range-end&gt;：一个整数，表示在特定单位下，范围的结束值。这个值是可选的，如果不存在，表示此范围一直延伸到文档结束。</span><br><span class="line"></span><br><span class="line">Range: bytes&#x3D;200-1000, 2000-6576, 19000-</span><br></pre></td></tr></table></figure><h4 id="From"><a href="#From" class="headerlink" title="From"></a>From</h4><p>提供了客户端用户的 E-mail 地址，<br>用处：比如你有一个爬虫程序，那么 Form 首部应该随请求一起发送，这样的话，在服务器遇到问题的时候，例如爬虫发送了过量的、不希望收到的或者不合法的请求时，站点管理员可以联系到你。</p><h3 id="5-3-响应首部"><a href="#5-3-响应首部" class="headerlink" title="5.3 响应首部"></a>5.3 响应首部</h3><h4 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h4><p>包含了处理请求的源头服务器所用到的软件相关信息</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Server: Apache-Coyote&#x2F;1.1</span><br></pre></td></tr></table></figure><h4 id="Set-Cookie"><a href="#Set-Cookie" class="headerlink" title="Set-Cookie"></a>Set-Cookie</h4><p>用来由服务器端向客户端发送 cookie。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">会话期 cookies 将会在客户端关闭时被移除。 </span><br><span class="line">会话期 cookie 不设置 Expires 或 Max-Age 指令</span><br><span class="line">Set-Cookie: sessionid&#x3D;38afes7a8; HttpOnly; Path&#x3D;&#x2F;</span><br><span class="line"></span><br><span class="line">持久化 Cookie 不会在客户端关闭时失效，而是在特定的日期（Expires）或者经过一段特定的时间之后（Max-Age）才会失效。</span><br><span class="line"></span><br><span class="line">Set-Cookie: id&#x3D;a3fWa; Expires&#x3D;Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly</span><br></pre></td></tr></table></figure><h4 id="Accept-Ranges"><a href="#Accept-Ranges" class="headerlink" title="Accept-Ranges"></a>Accept-Ranges</h4><p>响应中出现，表示服务器支持按字节来取范围数据</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Accept-Ranges: none</span><br><span class="line">none：不支持任何范围请求单位，由于其等同于没有返回此头部，因此很少使用。</span><br><span class="line">bytes：范围请求的单位是 bytes （字节）。</span><br><span class="line"></span><br><span class="line">Accept-Ranges: bytes</span><br></pre></td></tr></table></figure><h3 id="5-4-Body-首部"><a href="#5-4-Body-首部" class="headerlink" title="5.4 Body 首部"></a>5.4 Body 首部</h3><p>由于请求与响应中都可以包含 body部分，所以在请求报文与响应报文中都可以出现这部分字段。</p><h4 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h4><p>指定的是需要将页面重新定向至的地址。一般在响应码为 3xx 的响应中才会有意义。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Location: &#x2F;index.html</span><br></pre></td></tr></table></figure><h4 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h4><p>告诉客户端实际返回的内容的内容类型。<br><strong>主要分为一下 4 类:</strong></p><ul><li>text/html </li></ul><p>请求 Web ⻚面时返回响应的类型，Body 中返回 html 文本。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Content-Type: text&#x2F;html; charset&#x3D;utf-8</span><br><span class="line">Content-Length: 853</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br></pre></td></tr></table></figure><ul><li>x-www-form-urlencoded</li></ul><p>Web ⻚面纯⽂本表单的提交方式</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST  &#x2F;users  HTTP&#x2F;1.1</span><br><span class="line">Host: api.github.com</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 27</span><br><span class="line">name&#x3D;xxtlant&amp;gender&#x3D;male</span><br></pre></td></tr></table></figure><ul><li>multitype/form-data</li></ul><p>Web ⻚面含有⼆制⽂件时的提交方式。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST  &#x2F;users  HTTP&#x2F;1.1</span><br><span class="line">Host: hencoder.com</span><br><span class="line">Content-Type: multipart&#x2F;form-data; boundary&#x3D;----</span><br><span class="line">WebKitFormBoundary7MA4YWxkTrZu0gW</span><br><span class="line">Content-Length: 2382</span><br><span class="line">------WebKitFormBoundary7MA4YWxkTrZu0gW</span><br><span class="line">Content-Disposition: form-data; name&#x3D;&quot;name&quot;</span><br><span class="line">rengwuxian</span><br><span class="line">------WebKitFormBoundary7MA4YWxkTrZu0gW</span><br><span class="line">Content-Disposition: form-data; name&#x3D;&quot;avatar&quot;; filename&#x3D;&quot;avatar.jpg&quot;</span><br><span class="line">Content-Type: image&#x2F;jpeg</span><br><span class="line">JFIFHHvOwX9jximQrWa......</span><br><span class="line">------WebKitFormBoundary7MA4YWxkTrZu0gW--</span><br></pre></td></tr></table></figure><ul><li>application/json , image/jpeg , application/zip …</li></ul><p>单项内容(⽂本或非⽂本都可以)，用于 Web Api 的响应或者 POST / PUT 的请求。</p><blockquote><p>请求中提交 JSON</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;users HTTP&#x2F;1.1</span><br><span class="line">Host: api.github.com</span><br><span class="line">Content-Type: application&#x2F;json; charset&#x3D;utf-8</span><br><span class="line">Content-Length: 38</span><br><span class="line">&#123;&quot;name&quot;:&quot;xxtlant&quot;,&quot;gender&quot;:&quot;male&quot;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>响应中返回 JSON </p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Date: Tue, 12 Feb 2019 08:04:14 GMT</span><br><span class="line">Content-Type: application&#x2F;json; charset&#x3D;utf-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Server: GitHub.com</span><br><span class="line">Status: 200 OK</span><br><span class="line"></span><br><span class="line">&#123;&quot;login&quot;: &quot;xxtlant&quot;,</span><br><span class="line">&quot;id&quot;: 18342980,</span><br><span class="line">&quot;node_id&quot;: &quot;MDQ6VXNlcjE4MzQyOTgw&quot;,</span><br><span class="line">&quot;avatar_url&quot;: &quot;https:&#x2F;&#x2F;avatars2.githubusercontent.com&#x2F;u&#x2F;18342980?v&#x3D;4&quot;,</span><br><span class="line">&quot;gravatar_id&quot;: &quot;&quot;,</span><br><span class="line">....</span><br></pre></td></tr></table></figure><blockquote><p>请求中提交⼆进制内容</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;user&#x2F;1&#x2F;avatar HTTP&#x2F;1.1</span><br><span class="line">Host: hencoder.com</span><br><span class="line">Content-Type: image&#x2F;jpeg</span><br><span class="line">Content-Length: 1575</span><br><span class="line">JFIFHH9......</span><br></pre></td></tr></table></figure><blockquote><p>相应中返回⼆进制内容</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">content-type: image&#x2F;jpeg</span><br><span class="line">content-length: 1575</span><br><span class="line">JFIFHH9......</span><br></pre></td></tr></table></figure><h4 id="Content-length"><a href="#Content-length" class="headerlink" title="Content-length"></a>Content-length</h4><p>用来指明发送给接收方的消息主体的大小。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Length: &lt;length&gt;</span><br></pre></td></tr></table></figure><h4 id="Content-Encoding"><a href="#Content-Encoding" class="headerlink" title="Content-Encoding"></a>Content-Encoding</h4><p>用于对特定媒体类型的数据进行压缩。<br>这个消息用来告知客户端应该怎样解码才能获取在 Content-Type 中的媒体类型内容。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Encoding: gzip</span><br><span class="line"></span><br><span class="line">其值受 Accept-Encoding 影响</span><br></pre></td></tr></table></figure><p>与此对应，Content-Language 也与 Accept-Language 对应。</p><h2 id="六、参考链接"><a href="#六、参考链接" class="headerlink" title="六、参考链接"></a>六、参考链接</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP" target="_blank" rel="noopener">HTTP</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers" target="_blank" rel="noopener">HTTP Headers</a></li><li><a href="http://www.ruanyifeng.com/blog/2016/08/http.html" target="_blank" rel="noopener">HTTP 协议入门</a><!--more--></li></ul>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Google Cloud 搭建一年免费 Shadowsocks 教程</title>
      <link href="/posts/google_cloud_building_ssr.html"/>
      <url>/posts/google_cloud_building_ssr.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h4 id="以下内容，不需要编程基础"><a href="#以下内容，不需要编程基础" class="headerlink" title="以下内容，不需要编程基础"></a>以下内容，不需要编程基础</h4><ul><li>需要用到的工具<ul><li>可以访问 Google</li><li>信用卡一张</li><li>Google 账户</li></ul></li><li>如果没有科学上网工具，可以先下载使用 <a href="https://github.com/getlantern/forum/issues/833" target="_blank" rel="noopener">蓝灯免费版</a> 。</li></ul><a id="more"></a><h4 id="教程一共分为四步骤"><a href="#教程一共分为四步骤" class="headerlink" title="教程一共分为四步骤"></a>教程一共分为四步骤</h4><ol><li>使用 Google Cloud 部署虚拟机</li><li>升级VPS内核开启BBR</li><li>搭建 Shadowsocks Server</li><li>设置Shadowsocks server开机启动</li></ol><h3 id="一、-使用-Google-Cloud-部署虚拟机"><a href="#一、-使用-Google-Cloud-部署虚拟机" class="headerlink" title="一、 使用 Google Cloud 部署虚拟机"></a>一、 使用 Google Cloud 部署虚拟机</h3><h4 id="1-申请使用Google-Cloud"><a href="#1-申请使用Google-Cloud" class="headerlink" title="1.申请使用Google Cloud"></a>1.申请使用Google Cloud</h4><p>申请地址：<a href="https://cloud.google.com/free/" target="_blank" rel="noopener">点击此处</a></p><p>![Google Cloud 试用](../img/Google Cloud 试用.jpg)</p><p>![选择国家](../img/choose country.jpg)</p><p><img src="../img/%E5%A1%AB%E5%86%99%E5%9C%B0%E5%9D%80.jpg" alt=""></p><p><img src="../img/%E5%A1%AB%E5%86%99%E4%BF%A1%E7%94%A8%E5%8D%A1.jpg" alt="填写地址以及信用卡信息"></p><p>登陆 Google 账户，<strong>必须使用信用卡</strong>，而且不能使用虚拟卡，招商银行、中信银行的全币种卡、浦发银行的 VISA 卡均可以通过验证。理论上 VISA 卡均可获得通过，选择中国后绑定信用卡，填写个人信息，可如实填写信用卡账单地址。成功后会于扣款1刀，验证卡片后会返还。<br>GCD 现在免费赠送 300 刀期限是一年，也就是 300 刀和一年时间谁先用完就以谁为准，<strong>结束之后不点继续使用时不会扣费的</strong>。</p><p>跳转后，如果你能看到页面顶部有一个“礼物 🎁 ” 的小图标，或者说你收到了相应的邮件，说明试用金已到账</p><p><img src="/img/%E8%AF%95%E7%94%A8%E6%97%B6%E9%97%B4.jpg" alt="试用时间"></p><p>上图是我的剩余试用时间以及剩余赠金</p><h4 id="2-修改防火墙"><a href="#2-修改防火墙" class="headerlink" title="2.修改防火墙"></a>2.修改防火墙</h4><p>提前设置好后，后面设置完 ss 服务就可以直接使用了</p><p>访问链接：<a href="https://console.cloud.google.com/networking/firewalls/list" target="_blank" rel="noopener">点击此处</a></p><p>或者在菜单中依次点击【VPC 网络】 –&gt; 【防火墙规则】 –&gt; 【创建防火墙规则】</p><p><img src="/img/%E5%88%9B%E5%BB%BA%E9%98%B2%E7%81%AB%E5%A2%99%E8%A7%84%E5%88%99.jpg" alt="创建防火墙规则.jpg"></p><p>更改红色箭头指向的几项。<br>名称自己随意起，IP 地址范围：<strong>0.0.0.0/0</strong><br>点击创建会生成规则，请耐心等待。</p><h4 id="3-获取静态IP"><a href="#3-获取静态IP" class="headerlink" title="3.获取静态IP"></a>3.获取静态IP</h4><p>获取静态 IP 很重要，只有有了静态IP，后面部署的SS服务才能用。</p><p>设置地址:<a href="https://console.cloud.google.com/networking/addresses/list?project=allow-all-ip-port-xxtlant" target="_blank" rel="noopener">点击此处</a></p><p>或者在菜单中依次点击【VPC 网络】 –&gt; 【外部 IP 地址】 –&gt; 【保留静态地址】</p><p><img src="../img/%E4%BF%9D%E7%95%99%E9%9D%99%E6%80%81%E5%9C%B0%E5%9D%80.jpg" alt="保留静态地址.jpg"></p><p><strong>名称自定义即可</strong></p><p>PS：<strong>静态 IP 只能申请一个！！！</strong></p><p>大陆速度最佳的机房是台湾彰化的机房了，asia-east1-c对大陆最友好<br>还有东京亚洲东区，也就是东京机房了asia-northeast1-a</p><h4 id="4-创建计算引擎"><a href="#4-创建计算引擎" class="headerlink" title="4.创建计算引擎"></a>4.创建计算引擎</h4><p>设置地址:<a href="https://console.cloud.google.com/compute/instances" target="_blank" rel="noopener">点击此处</a></p><p>或者在菜单中依次点击【计算引擎】–&gt; 【创建实例】</p><p><img src="../img/%E5%88%9B%E5%BB%BA%E8%AE%A1%E7%AE%97%E5%AE%9E%E4%BE%8B.jpg" alt="创建计算实例.jpg"></p><p>如图，机器类型选最便宜的<strong>微型</strong>就够用，启动磁盘选<strong>Ubuntu16.04LTS</strong>，我参照的教程是使用Ubuntu1604，所以我选择了这个。<br>点击蓝色箭头指向的 【管理、磁盘、网络、SSH 密钥】，去设置网络。</p><p><img src="../img/%E8%AE%BE%E7%BD%AE%E7%BD%91%E7%BB%9C.jpg" alt="设置网络.jpg"></p><p><img src="../img/%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81%E5%9C%B0%E5%9D%80.jpg" alt="设置静态地址.jpg"></p><p>按图所示，点击 主要内部 IP 的保留静态 IP 地址，然后选择刚才创建的静态 IP 即可。点击创建即可完成。<br>等待一会后，出现下图所示，即已经完成创建。</p><p><img src="../img/%E5%AE%9E%E4%BE%8B.jpg" alt="实例.jpg"></p><p>至此，第一步已经完成。</p><h3 id="二、升级VPS内核开启BBR-这一步，我不懂，是参考搜到的教程来设定的"><a href="#二、升级VPS内核开启BBR-这一步，我不懂，是参考搜到的教程来设定的" class="headerlink" title="二、升级VPS内核开启BBR(这一步，我不懂，是参考搜到的教程来设定的)"></a>二、升级VPS内核开启BBR(这一步，我不懂，是参考搜到的教程来设定的)</h3><p>由于众所周知的原因，单纯部署完shadowsocks服务之后速度都不会太理想，即使你选择的是台湾、日本这种很好的线路，依然会存在丢包和不稳定的情况。</p><p>点击上图创建实例完成后，右边的 SSH。会弹出一个页面，如下图：</p><p>![SSH 页面.jpg](../img/SSH 页面.jpg)</p><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>进入 ssh 后，先获取 root 权限</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo –i</span><br></pre></td></tr></table></figure><p>更新系统，两步分开执行，第二步耗时久一些</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt upgrade</span><br></pre></td></tr></table></figure><p>查看当前内核</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uname –a</span><br></pre></td></tr></table></figure><h4 id="启用BBR"><a href="#启用BBR" class="headerlink" title="启用BBR"></a>启用BBR</h4><p>写入配置 两步分开执行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;net.core.default_qdisc&#x3D;fq&quot; &gt;&gt; &#x2F;etc&#x2F;sysctl.conf</span><br><span class="line"></span><br><span class="line">echo &quot;net.ipv4.tcp_congestion_control&#x3D;bbr&quot; &gt;&gt; &#x2F;etc&#x2F;sysctl.conf</span><br></pre></td></tr></table></figure><p>配置生效</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><p>检验</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lsmod | grep bbr</span><br></pre></td></tr></table></figure><p>看到显示<code>tcp_bbr 20480 xx</code> 说明已经成功开启 BBR。<strong>不需要重新启动</strong></p><p>至此，第二步已经结束，接下来直接开始在虚拟机部署 SS 服务。</p><h3 id="三、搭建-Shadowsocks-Server"><a href="#三、搭建-Shadowsocks-Server" class="headerlink" title="三、搭建 Shadowsocks Server"></a>三、搭建 Shadowsocks Server</h3><p>首先更新一下 apt-get 软件包</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p>然后通过 apt-get 安装 python-pip</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install python-pip</span><br></pre></td></tr></table></figure><p>完成之后使用 pip 安装 shadowsocks 服务</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pip install shadowsocks</span><br></pre></td></tr></table></figure><p><img src="../img/%E5%AE%89%E8%A3%85Shadowsocks.jpg" alt="安装Shadowsocks.jpg"></p><p>说明安装成功了。</p><p>然后我们需要创建一个 shadowsocks server 的配置文件，可以直接建在当前用户目录下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim &#x2F;etc&#x2F;ss-conf.json</span><br></pre></td></tr></table></figure><p>回车之后会进入这个创建的文件，<br>按键盘上的 i 键会进入编辑，然后把下面的内容输入进去。<br>按ESC键会发现左下角的insert消失，<br>使用组合键 <strong>shift 加 ：</strong> ，这个组合键左下角出现<strong>：</strong>，然后输入 <strong>wq</strong> 回车就保存退出文件。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;server&quot;:&quot;0.0.0.0&quot;,</span><br><span class="line">&quot;server_port&quot;:000,</span><br><span class="line">&quot;local_address&quot;:&quot;127.0.0.1&quot;,</span><br><span class="line">&quot;local_port&quot;:1080,</span><br><span class="line">&quot;password&quot;:&quot;123456&quot;,</span><br><span class="line">&quot;timeout&quot;:600,</span><br><span class="line">&quot;method&quot;:&quot;aes-256-cfb&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的内容复制到创建的文件里就可以了。</p><p><font size =4><strong>注意</strong></p><ol><li>代码的全部内容必须为<strong>英文半角输入</strong>，</li><li><strong>server_port</strong>与<strong>password</strong>后面的数字内容<strong>请自己设定</strong>，这两个是你之后在shadowsocks客户端上配置使用的<strong>端口和密码</strong>。</font></li></ol><p>最后用这个配置文件启动 shadowsocks 服务</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ssserver -c &#x2F;etc&#x2F;ss-conf.json -d start</span><br></pre></td></tr></table></figure><h3 id="四、开启-Shadowsocks-Server-开机启动"><a href="#四、开启-Shadowsocks-Server-开机启动" class="headerlink" title="四、开启 Shadowsocks Server 开机启动"></a>四、开启 Shadowsocks Server 开机启动</h3><p>服务器可能会自动重启，这样的话就需要每次手动开启SS服务，很麻烦而且还会遇到要用梯子但是梯子在墙外的这种困境，怎么办呢？那么我们进入第四步，写脚本让系统开机后自动启动ss服务。</p><p>创建脚本 /etc/init.d/shadowsocks</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim &#x2F;etc&#x2F;init.d&#x2F;shadowsocks</span><br></pre></td></tr></table></figure><p>进入文件后添加以下内容,方法与前面创建ss-conf.json这个文件一样，使用键盘字母 <strong>i</strong> 键、<strong>shif 加 ：</strong>、<strong>wq</strong>回车保存等等</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line">### BEGIN INIT INFO</span><br><span class="line"># Provides: shadowsocks</span><br><span class="line"># Required-Start: $remote_fs $syslog</span><br><span class="line"># Required-Stop: $remote_fs $syslog</span><br><span class="line"># Default-Start: 2 3 4 5</span><br><span class="line"># Default-Stop: 0 1 6</span><br><span class="line"># Short-Description: start shadowsocks</span><br><span class="line"># Description: start shadowsocks</span><br><span class="line">### END INIT INFO</span><br><span class="line">start()&#123;</span><br><span class="line">　　　ssserver -c &#x2F;etc&#x2F;ss-conf.json -d start</span><br><span class="line">&#125;</span><br><span class="line">stop()&#123;</span><br><span class="line">　　　ssserver -c &#x2F;etc&#x2F;ss-conf.json -d stop</span><br><span class="line">&#125;</span><br><span class="line">case “$1” in</span><br><span class="line">start)</span><br><span class="line">　　　start</span><br><span class="line">　　　;;</span><br><span class="line">stop)</span><br><span class="line">　　　stop</span><br><span class="line">　　　;;</span><br><span class="line">reload)</span><br><span class="line">　　　stop</span><br><span class="line">　　　start</span><br><span class="line">　　　;;</span><br><span class="line">*)</span><br><span class="line">　　　echo “Usage: $0 &#123;start|reload|stop&#125;”</span><br><span class="line">　　　exit 1</span><br><span class="line">　　　;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p>然后增加这个文件的可执行权限</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo chmod +x &#x2F;etc&#x2F;init.d&#x2F;shadowsocks</span><br></pre></td></tr></table></figure><p>创建文件 /etc/init/shadowsocks.conf</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim &#x2F;etc&#x2F;init&#x2F;shadowsocks.conf</span><br></pre></td></tr></table></figure><p>内容直接复制如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start on (runlevel [2345])stop on (runlevel [016])pre-start script</span><br><span class="line">&#x2F;etc&#x2F;init.d&#x2F;shadowsocks start</span><br><span class="line">end script</span><br><span class="line"></span><br><span class="line">post-stop script</span><br><span class="line">&#x2F;etc&#x2F;init.d&#x2F;shadowsocks stop</span><br><span class="line">end script</span><br></pre></td></tr></table></figure><p>执行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo update-rc.d shadowsocks defaults</span><br></pre></td></tr></table></figure><p>然后就添加到开机启动中了<br>最后你可以 <strong>Reboot</strong> 测试一下看是否成功，若未成功就check一下第四步哪里有问题。</p><p>至此搭建已经全部完成了。</p><p><img src="../img/Youtube%E6%B5%8B%E8%AF%95.jpg" alt="Youtube测试.jpg"></p><h3 id="SSR-客户端-下载地址"><a href="#SSR-客户端-下载地址" class="headerlink" title="SSR 客户端 下载地址"></a>SSR 客户端 <a href="http://shadowsocks.org/en/download/clients.html" target="_blank" rel="noopener">下载地址</a></h3><p>直接下载文件</p><p><a href="/img/ShadowsocksX-NG.1.7.1.zip">Mac 版</a></p><p><a href="/img/com.github.shadowsocks.apk">Android</a></p><!--more-->]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React Native 开发环境搭建</title>
      <link href="/posts/RN_develop_environment_building.html"/>
      <url>/posts/RN_develop_environment_building.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="什么是-React-Native"><a href="#什么是-React-Native" class="headerlink" title="什么是 React Native"></a>什么是 React Native</h2><blockquote><p>React Native (简称 RN)是 Facebook 于 2015 年开源的一套跨平台，动态更新的 JavaScript 框架。<br>口号是：Learn once, write anywhere: Build mobile apps with React<br>着力于提高多平台开发的开发效率 —— 仅需学习一次，编写任何平台。</p></blockquote> <a id="more"></a><h2 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h2><p>我用的电脑是 MacBook,搭建的环境是 MacOS + Android 。<br>其他例如搭建 iOS, Windows, Linux 的环境，请参考 <a href="http://reactnative.cn/docs/0.49/getting-started.html#content" target="_blank" rel="noopener">React Native 中文网的搭建开发环境</a> , <a href="http://facebook.github.io/react-native/docs/getting-started.html" target="_blank" rel="noopener">React Native 官方的 Getting Started</a> 这两篇文章。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="安装必须的软件"><a href="#安装必须的软件" class="headerlink" title="安装必须的软件"></a>安装必须的软件</h4><blockquote><p>需要安装 Node.js , Watchman, React Native命令行界面, JDK 和 Android Studio</p></blockquote><h5 id="HomeBrew"><a href="#HomeBrew" class="headerlink" title="HomeBrew"></a>HomeBrew</h5><p><a href="https://brew.sh/" target="_blank" rel="noopener">Homebrew</a>, Mac 系统的包管理器，用于安装 NodeJS 和其他一些必需的工具软件</p><blockquote><p>/usr/bin/ruby -e “$(curl -fsSL <a href="https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;" target="_blank" rel="noopener">https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</a></p></blockquote><p>直接复制上述命令，在终端运行就可以了。<br>译注：在Max OS X 10.11（El Capitan)版本中，homebrew在安装软件时可能会碰到/usr/local目录不可写的权限问题。可以使用下面的命令修复：</p><blockquote><p>sudo chown -R `whoami` /usr/local</p></blockquote><h5 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h5><p>使用 HomeBrew 来安装<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a></p><blockquote><p>brew install node</p></blockquote><p>安装完 node 后建议设置 npm 镜像以加速后面的过程（或使用科学上网工具）。注意：不要使用 cnpm！cnpm 安装的模块路径比较奇怪，packager不能正常识别！</p><blockquote><p>npm config set registry <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a> –global<br>npm config set disturl <a href="https://npm.taobao.org/dist" target="_blank" rel="noopener">https://npm.taobao.org/dist</a> –global</p></blockquote><h5 id="Yarn、React-Native的命令行工具（react-native-cli）"><a href="#Yarn、React-Native的命令行工具（react-native-cli）" class="headerlink" title="Yarn、React Native的命令行工具（react-native-cli）"></a>Yarn、React Native的命令行工具（react-native-cli）</h5><p><a href="https://yarnpkg.com/zh-Hans/" target="_blank" rel="noopener">Yarn</a> 是 Facebook 提供的替代 npm 的工具，可以加速 node 模块的下载。React Native 的命令行工具用于执行创建、初始化、更新项目、运行打包服务（packager）等任务。</p><blockquote><p>npm install -g yarn react-native-cli</p></blockquote><p>安装完 yarn 后也要设置镜像源:</p><blockquote><p>yarn config set registry <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a> –global<br>yarn config set disturl <a href="https://npm.taobao.org/dist" target="_blank" rel="noopener">https://npm.taobao.org/dist</a> –global</p></blockquote><p>如果你看到 <strong><code>EACCES: permission denied</code></strong> 这样的权限报错，那么请参照上文的 homebrew 译注，修复 <code>/usr/local</code> 目录的所有权：</p><blockquote><p>sudo chown -R `whoami` /usr/local</p></blockquote><p>安装完yarn之后就可以用 <code>yarn</code> 代替 <code>npm</code> 了，例如用 <code>yarn</code> 代替 <code>npm install</code> 命令，用 <code>yarn add</code> 某第三方库名代替 <code>npm install --save</code> 某第三方库名。 </p><h5 id="Java-开发工具包"><a href="#Java-开发工具包" class="headerlink" title="Java 开发工具包"></a>Java 开发工具包</h5><p>React Native需要最新版本的Java SE开发工具包（JDK）。如果需要，<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">下载并安装JDK 8或更高版本</a>。</p><h5 id="Android-开发环境"><a href="#Android-开发环境" class="headerlink" title="Android 开发环境"></a>Android 开发环境</h5><h6 id="1-安装-Android-Studio"><a href="#1-安装-Android-Studio" class="headerlink" title="1. 安装 Android Studio"></a>1. 安装 Android Studio</h6><p>下载并安装Android Studio 。如果可以科学上网，可以在<a href="https://developer.android.google.cn/index.html" target="_blank" rel="noopener">Android Developers</a> 下载，也可以在 <a href="http://www.android-studio.org/" target="_blank" rel="noopener">Android Studio 中文社区</a> 进行下载。<br>Android Studio包含了运行和测试React Native应用所需的Android SDK和模拟器。</p><blockquote><p>除非特别注明，请不要改动安装过程中的选项。比如Android Studio默认安装了 Android Support Repository，而这也是React Native必须的（否则在react-native run-android时会报appcompat-v7包找不到的错误）。</p></blockquote><p>安装过程中需要改动的选项:</p><ul><li>选择 <code>Custom</code> 选项:<br>  <img src="http://reactnative.cn/static/docs/0.49/img/react-native-android-studio-custom-install.png" alt="选择 Custom"></li><li>勾选 <code>Performance</code> 和 <code>Android Virtual Device</code><br>  <img src="http://reactnative.cn/static/docs/0.49/img/react-native-android-studio-additional-installs.png" alt="选择"></li><li>安装完成后，在 Android Studio 的启动欢迎界面中选择 <strong>Configure | SDK Manager</strong>。<br>  <img src="http://reactnative.cn/static/docs/0.49/img/react-native-android-studio-configure-sdk.png" alt="选择 SDK Manager"></li><li>在 <code>SDK Platforms</code> 窗口中，选择 <code>Show Package Details</code>，然后在Android 6.0 (Marshmallow)中勾选<ul><li><strong>Google APIs</strong></li><li><strong>Android SDK Platform 23</strong></li><li><strong>Intel x86 Atom_64 System Image</strong></li><li><strong>Google APIs Intel x86 Atom_64 System Image</strong><br><img src="http://reactnative.cn/static/docs/0.49/img/react-native-android-studio-android-sdk-platforms.png" alt="勾选指定项"></li></ul></li><li>在 <strong>SDK Tools</strong> 窗口中，选择 Show Package Details，然后在 Android SDK Build Tools 中勾选 <strong>Android SDK Build-Tools 23.0.1（必须是这个版本）</strong>。然后还要勾选最底部的 <strong>Android Support Repository</strong>.<br>  <img src="http://reactnative.cn/static/docs/0.49/img/react-native-android-studio-android-sdk-build-tools.png" alt="勾选 SDK Tools"></li></ul><h6 id="2-ANDROID-HOME-环境变量"><a href="#2-ANDROID-HOME-环境变量" class="headerlink" title="2. ANDROID_HOME 环境变量"></a>2. ANDROID_HOME 环境变量</h6><p>确保 <strong>ANDROID_HOME</strong> 环境变量正确地指向了你安装的 Android SDK 的路径。具体的做法是把下面的命令加入到 <code>~/.bash_profile</code> 文件中：(<strong>译注</strong>：~ 表示用户目录，即<code>/Users/你的用户名/</code>，而小数点开头的文件在 Finder 中是隐藏的，并且这个文件有可能并不存在。请在终端下使用 <code>vi ~/.bash_profile</code> 命令创建或编辑。如不熟悉 vi 操作，请点击<a href="http://www.eepw.com.cn/article/48018.htm" target="_blank" rel="noopener">这里</a> 学习）。如果你的命令行不是bash，而是例如 zsh 等其他，请使用对应的配置文件。</p><blockquote><p>如果你不是通过Android Studio安装的sdk，则其路径可能不同，请自行确定清楚。<br>export ANDROID_HOME=~/Library/Android/sdk</p></blockquote><p>然后使用下列命令使其立即生效（否则重启后才生效）：</p><blockquote><p>source ~/.bash_profile</p></blockquote><p>可以使用 <strong><code>echo $ANDROID_HOME</code></strong> 检查此变量是否已正确设置。</p><h5 id="Watchman"><a href="#Watchman" class="headerlink" title="Watchman"></a>Watchman</h5><p><a href="https://facebook.github.io/watchman/docs/install.html" target="_blank" rel="noopener">Watchman</a>是由 Facebook 提供的监视文件系统变更的工具。安装此工具可以提高开发时的性能（packager可以快速捕捉文件的变化从而实现实时刷新）。</p><blockquote><p>brew install watchman</p></blockquote><h5 id="将Android-SDK的Tools目录添加到PATH变量中"><a href="#将Android-SDK的Tools目录添加到PATH变量中" class="headerlink" title="将Android SDK的Tools目录添加到PATH变量中"></a>将Android SDK的Tools目录添加到PATH变量中</h5><p>把 Android SDK 的 tools 和 platform-tools 目录添加到 <strong>PATH</strong> 变量中，以便在终端中运行一些 Android 工具，例如 <code>android avd</code> 或是 <code>adb logcat</code> 等。具体做法仍然是在 <code>~/.bash_profile</code> 中添加：</p><blockquote><p>export PATH=$PATH:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools</p></blockquote><h4 id="其他可选的安装项"><a href="#其他可选的安装项" class="headerlink" title="其他可选的安装项"></a>其他可选的安装项</h4><h5 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h5><p>Git 版本控制。如若没有，则使用下列命令安装：</p><blockquote><p>brew install git</p></blockquote><h5 id="Nuclide"><a href="#Nuclide" class="headerlink" title="Nuclide"></a>Nuclide</h5><p><a href="https://nuclide.io/" target="_blank" rel="noopener">Nuclide</a> （此链接需要科学上网）是由 Facebook 提供的基于 <strong>atom</strong> 的集成开发环境，可用于编写、<a href="http://nuclide.io/docs/platforms/react-native/#running-applications" target="_blank" rel="noopener">运行</a>和 <a href="https://nuclide.io/docs/platforms/react-native/#debugging" target="_blank" rel="noopener">调试</a>React Native应用。</p><p>点击这里阅读<a href="http://nuclide.io/docs/quick-start/getting-started/" target="_blank" rel="noopener">Nuclide的入门文档</a>。</p><h5 id="Genymotion"><a href="#Genymotion" class="headerlink" title="Genymotion"></a>Genymotion</h5><p>Genymotion是一个性能更好的选择，但它只对个人用户免费。</p><ol><li>下载和安装<a href="https://www.genymotion.com/download" target="_blank" rel="noopener">Genymotion</a>（genymotion需要依赖VirtualBox虚拟机，下载选项中提供了包含VirtualBox和不包含的选项，请按需选择）。</li><li>打开Genymotion。如果你还没有安装VirtualBox，则此时会提示你安装。</li><li>创建一个新模拟器并启动。</li><li>启动React Native应用后，可以按下⌘+M来打开开发者菜单</li></ol><h5 id="Gradle-Daemon"><a href="#Gradle-Daemon" class="headerlink" title="Gradle Daemon"></a>Gradle Daemon</h5><p>开启 <a href="https://docs.gradle.org/2.9/userguide/gradle_daemon.html" target="_blank" rel="noopener">Gradle Daemon</a> 可以极大地提升java代码的增量编译速度。</p><blockquote><p>touch ~/.gradle/gradle.properties &amp;&amp; echo “org.gradle.daemon=true” &gt;&gt; ~/.gradle/gradle.properties</p></blockquote><h2 id="测试安装"><a href="#测试安装" class="headerlink" title="测试安装"></a>测试安装</h2><blockquote><p>react-native init AwesomeProject</p></blockquote><blockquote><p>cd AwesomeProject</p></blockquote><blockquote><p>react-native run-android</p></blockquote><blockquote><p>提示：你可以使用–version参数创建指定版本的项目。例如 react-native init MyApp –version 0.39.2。注意版本号必须精确到两个小数点.</p></blockquote><p>你也可以在 <a href="https://nuclide.io/" target="_blank" rel="noopener">Nuclide</a> 中打开AwesomeProject文件夹然后<a href="http://nuclide.io/docs/platforms/react-native/#running-applications" target="_blank" rel="noopener">运行</a>。</p><blockquote><p>注意，react-native run-android 时，需要打开一个 Android 设备的模拟器，不然会报错</p></blockquote><h3 id="其他问题。"><a href="#其他问题。" class="headerlink" title="其他问题。"></a>其他问题。</h3><p>如果看完这些，还有其他问题，请查阅 <a href="http://reactnative.cn/" target="_blank" rel="noopener">React Native 中文网</a>，里面有详细的使用文档。<br>或者参阅 <a href="http://facebook.github.io/react-native/" target="_blank" rel="noopener">Facebook 的 React Native 的官方文档</a>.</p><p>我也是一个初学者，谢谢。</p> <!--more-->]]></content>
      
      
      <categories>
          
          <category> React Native </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React Native </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 开发实用小技巧</title>
      <link href="/posts/android_develop_skill.html"/>
      <url>/posts/android_develop_skill.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="文本与布局"><a href="#文本与布局" class="headerlink" title="文本与布局"></a>文本与布局</h3><ol><li><p>字符串资源里的变量替换<br>当程序中使用字符串如第 345 页，我们不可能使用两个字符串资源如</p> <figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;string name="di"&gt;第&lt;/string&gt; </span><br><span class="line">&lt;string name="page"&gt;页&lt;/string&gt;</span><br></pre></td></tr></table></figure> <a id="more"></a><p>在 android 中有一个东西是 XLIFF，全称是 XML 本地化数据交换格式，英文是 XML Loca lization Interchange File Format。<br>用法很简单，如下所示</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;string name="page"&gt;第%1$s页&lt;/string&gt;</span><br><span class="line">程序中只要给变量赋值就好了，如下：</span><br><span class="line">String page = getString(R.string.page,<span class="string">"345"</span>);</span><br></pre></td></tr></table></figure><p>要是有多个变量，如第 345 页 24 行 ? 这也好办，如下:</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;string name="page"&gt;第%1$s页%2$s行&lt;/string&gt;</span><br><span class="line">String page = getString(R.string.page,<span class="string">"345"</span>,<span class="string">"24"</span>);</span><br></pre></td></tr></table></figure></li><li><p>TextView 设置多种字体大小</p><p><img src="https://github.com/xxtlant/BlogPicture/blob/master/android%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/TextViewSpan.png?raw=true" alt="TextView字体"></p><p>像这样的两种字体，要如何处理呢</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    String text = <span class="string">"Android实战技巧之文本与布局"</span>;</span><br><span class="line">    <span class="keyword">int</span> start = text.indexOf(<span class="string">'之'</span>);</span><br><span class="line">    <span class="keyword">int</span> end = text.length();</span><br><span class="line">    Spannable textSpan =  <span class="keyword">new</span> SpannableString(text);</span><br><span class="line">    textSpan.setSpan(<span class="keyword">new</span> AbsoluteSizeSpan(<span class="number">20</span>), <span class="number">0</span>, start,</span><br><span class="line">                    Spannable.SPAN_INCLUSIVE_INCLUSIVE);</span><br><span class="line">    textSpan.setSpan(<span class="keyword">new</span> AbsoluteSizeSpan(<span class="number">12</span>), start,</span><br><span class="line">                    end, Spannable.SPAN_INCLUSIVE_INCLUSIVE);</span><br><span class="line">    ``` </span><br><span class="line">    这个 textSpan 就是你想要的。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. TextView 的超链接</span><br><span class="line">  这个很简单，在 xml 中属性 `autoLink=“all”`。</span><br><span class="line">  程序中 `TextView.setAutoLink(Linkify.ALL)`;</span><br><span class="line">  说一下 `autoLink` 中的参数：</span><br><span class="line"></span><br><span class="line">    ```java</span><br><span class="line">    Linkify.EMAIL_ADDRESS -- 仅识别出 TextView 中的 Email 在址，标识为超链接，点击后会跳到 Email，发送邮件给此地址</span><br><span class="line">    Linkify.PHONE_NUMBERS -- 仅识别出 TextView 中的电话号码，标识为超链接，点击后会跳到 Dialer，Call 这个号码</span><br><span class="line">    Linkify.WEB_URLS-- 仅识别出 TextView 中的网址，标识为超链接，点击后会跳到 Browser 打开此 URL Linkify.ALL -- 这个选项是识别出所有系统所支持的特殊 Uri，然后做相应的操作</span><br></pre></td></tr></table></figure><p> 特殊情况:<br>当一段文字部分是超链接或者我们需要点击超链接跳到另一个 Activity时，如何处理?</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TextView testText;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        testText = (TextView) findViewById(R.id.testText); </span><br><span class="line">        <span class="comment">//将TextView的显示文字设置为SpannableString</span></span><br><span class="line">        testText.setText(getClickableSpan());</span><br><span class="line">        <span class="comment">//设置该句使文本的超连接起作用</span></span><br><span class="line">        testText.setMovementMethod(LinkMovementMethod.getInstance());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置超链接文字</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> SpannableString <span class="title">getClickableSpan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SpannableString spanStr = <span class="keyword">new</span> SpannableString(<span class="string">"使用该软件，即表示您同意该软件的使用条款和隐私政策"</span>); <span class="comment">//设置下划线文字</span></span><br><span class="line">        spanStr.setSpan(<span class="keyword">new</span> UnderlineSpan(), <span class="number">16</span>, <span class="number">20</span>, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); <span class="comment">//设置文字的单击事件</span></span><br><span class="line">        spanStr.setSpan(<span class="keyword">new</span> ClickableSpan() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View widget)</span> </span>&#123;</span><br><span class="line">                startActivity(<span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, TestActivity1<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">16</span>, <span class="number">20</span>, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);</span><br><span class="line">        <span class="comment">//设置文字的前景色</span></span><br><span class="line">        spanStr.setSpan(<span class="keyword">new</span> ForegroundColorSpan(Color.WHITE), <span class="number">16</span>, <span class="number">20</span>, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); <span class="comment">//设置下划线文字</span></span><br><span class="line">        spanStr.setSpan(<span class="keyword">new</span> UnderlineSpan(), <span class="number">21</span>, <span class="number">25</span>, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);</span><br><span class="line">        <span class="comment">//设置文字的单击事件</span></span><br><span class="line">        spanStr.setSpan(<span class="keyword">new</span> ClickableSpan() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View widget)</span> </span>&#123;</span><br><span class="line">                startActivity(<span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, TestActivity2<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">21</span>, <span class="number">25</span>, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);</span><br><span class="line">        <span class="comment">//设置文字的前景色</span></span><br><span class="line">        spanStr.setSpan(<span class="keyword">new</span> ForegroundColorSpan(Color.WHITE), <span class="number">21</span>, <span class="number">25</span>, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);</span><br><span class="line">        <span class="keyword">return</span> spanStr;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line">4. Java 文件中字体加粗</span><br><span class="line"></span><br><span class="line">    &#96;&#96;&#96;java</span><br><span class="line">    &#x2F;&#x2F;Typeface </span><br><span class="line">    textView.setTypeface(Typeface.defaultFromStyle(Typeface.BOLD));</span><br><span class="line">    &#x2F;&#x2F;use TextPaint</span><br><span class="line">    textView.getPaint().setFakeBoldText(true);</span><br></pre></td></tr></table></figure></li></ol><h3 id="按钮控制-ViewPager-的左右翻页"><a href="#按钮控制-ViewPager-的左右翻页" class="headerlink" title="按钮控制 ViewPager 的左右翻页"></a>按钮控制 ViewPager 的左右翻页</h3><p>为了实现左右翻页的效果，使用了 ViewPager，它会很方便的实现左右滑动后翻页。 这时需要自己也加上两个 button 来实现同样的操作，如何实现呢?<br>通过查看 ViewPager 的源码，里面有一个公共方法 arrowScroll ，查看代码 们可以有两个重要的发现:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">executeKeyEvent</span><span class="params">(KeyEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (event.getAction() == KeyEvent.ACTION_DOWN) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (event.getKeyCode()) &#123;</span><br><span class="line">                <span class="keyword">case</span> KeyEvent.KEYCODE_DPAD_LEFT: <span class="comment">//键盘方向键左键的控制，向左翻页</span></span><br><span class="line">                    handled = arrowScroll(FOCUS_LEFT);<span class="comment">//FOCUS_LEFT:17</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> KeyEvent.KEYCODE_DPAD_RIGHT:<span class="comment">//键盘方向键右键的控制，向右翻页</span></span><br><span class="line">                    handled = arrowScroll(FOCUS_RIGHT);<span class="comment">//FOCUS_RIGHT:66</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> KeyEvent.KEYCODE_TAB:</span><br><span class="line">                    <span class="keyword">if</span> (event.hasNoModifiers()) &#123;</span><br><span class="line">                        handled = arrowScroll(FOCUS_FORWARD);<span class="comment">// 向前 -&gt; 右翻 FOCUS_FORWARD:2</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.hasModifiers(KeyEvent.META_SHIFT_ON)) &#123;</span><br><span class="line">                        handled = arrowScroll(FOCUS_BACKWARD);<span class="comment">// 向后 -&gt; 左翻 FOCUS_BACKWARD:1</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">arrowScroll</span><span class="params">(<span class="keyword">int</span> direction)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (nextFocused != <span class="keyword">null</span> &amp;&amp; nextFocused != currentFocused) &#123;</span><br><span class="line">            <span class="keyword">if</span> (direction == View.FOCUS_LEFT) &#123;</span><br><span class="line">                ... <span class="comment">// 省略一些无关代码</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (direction == View.FOCUS_RIGHT) &#123;</span><br><span class="line">                ... <span class="comment">// 省略一些无关代码</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (direction == FOCUS_LEFT || direction == FOCUS_BACKWARD)&#123; <span class="comment">// 17 or 1 向左翻页</span></span><br><span class="line">            <span class="comment">// Trying to move left and nothing there; try to page.</span></span><br><span class="line">            handled = pageLeft();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (direction == FOCUS_RIGHT || direction == FOCUS_FORWARD) &#123; <span class="comment">// 66 or 2 向右翻页</span></span><br><span class="line">            <span class="comment">// Trying to move right and nothing there; try to page.</span></span><br><span class="line">            handled = pageRight();</span><br><span class="line">        &#125;</span><br><span class="line">        ... <span class="comment">//省略一些无关代码</span></span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>也就是说， 我们调用 arrowScroll 方法用参数 1 或者 17 就可以实现向左翻页;参数 2 或 66 就可以实现向右翻页。 后记:<br>当你的 UI 中有 EditText 这种获得 focus 的 widget 时， 必须用 17 和 66，否则要报错。</p><h3 id="获得屏幕物理尺寸、密度及分辨率"><a href="#获得屏幕物理尺寸、密度及分辨率" class="headerlink" title="获得屏幕物理尺寸、密度及分辨率"></a>获得屏幕物理尺寸、密度及分辨率</h3><h4 id="获取屏幕的宽高"><a href="#获取屏幕的宽高" class="headerlink" title="获取屏幕的宽高"></a>获取屏幕的宽高</h4><p>需要注意的原来经常使用的 getHeight() 与 getWidth() 已经不推荐使用了，建议使用 getSize()来替代。</p><p>参数是一个返回参数，用以返回分辨率的 Point，这个 Point 也比较简单，我们只需要关注 x 和 y 这两个成员就可以了。<br>用法如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSize</span><span class="params">(Point outSize)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        updateDisplayInfoLocked();  </span><br><span class="line">        mDisplayInfo.getAppMetrics(mTempMetrics, mDisplayAdjustments);</span><br><span class="line">        outSize.x = mTempMetrics.widthPixels;</span><br><span class="line">        outSize.y = mTempMetrics.heightPixels;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外 <code>Display</code>又提供了另一个方法：<code>getRealSize()</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getRealSize</span><span class="params">(Point outSize)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        updateDisplayInfoLocked();</span><br><span class="line">        outSize.x = mDisplayInfo.logicalWidth; </span><br><span class="line">        outSize.y = mDisplayInfo.logicalHeight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从两个方法的实现上看是有区别的。那么差异究竟在哪里，下面做一些实验来验证一下。<br>当<code>Activity</code>的主题是全屏主题时 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">android:theme=<span class="string">"@android:style/Theme.Black.NoTitleBar.Fullscreen"</span> </span><br><span class="line">android:theme=<span class="string">"@android:style/Theme.NoTitleBar.Fullscreen"</span></span><br></pre></td></tr></table></figure><p>二者返回的宽高是一样的，但是当不是全屏主题是，例如 <code>Activity</code> 主题有<code>ToolBar/ActionBar</code>时，二者返回的宽高就不一样了。<br>测试如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getSize():</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getDisplaySize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Point point = <span class="keyword">new</span> Point(); getWindowManager().getDefaultDisplay().getSize (point);     </span><br><span class="line">    Log.d(TAG,<span class="string">"the screen size is "</span>+point.toString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果如下 返回的高度是去掉 toolbar 的高度</span></span><br><span class="line">D/SecondActivity: <span class="function">the screen size is <span class="title">Point</span><span class="params">(<span class="number">1080</span>, <span class="number">1794</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">getRealSize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getDisplayInfomation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Point point = <span class="keyword">new</span> Point(); getWindowManager().getDefaultDisplay().getSize (point);</span><br><span class="line">    Log.d(TAG,<span class="string">"the screen size is "</span>+point.toString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果如下 是屏幕真实的宽高</span></span><br><span class="line">D/SecondActivity: <span class="function">the screen size is <span class="title">Point</span><span class="params">(<span class="number">1080</span>, <span class="number">1920</span>)</span></span></span><br></pre></td></tr></table></figure><h4 id="屏幕尺寸，设备的物理屏幕尺寸"><a href="#屏幕尺寸，设备的物理屏幕尺寸" class="headerlink" title="屏幕尺寸，设备的物理屏幕尺寸"></a>屏幕尺寸，设备的物理屏幕尺寸</h4><ol><li><p>屏幕尺寸，设备的物理屏幕尺寸<br> 现如今 <code>Android</code> 手机尺寸杂乱无章，有规则的，也有奇葩的尺寸，<a href="http://screensiz.es/" target="_blank" rel="noopener">手机屏幕尺寸</a> 这个网站，记录了一些 <code>Android、IOS</code> 屏幕的尺寸比例。<br> 不同的屏幕尺寸是可以通过采用相同的分辨率，它们之间的区别就在于<strong>密度(density)</strong>不同</p></li><li><p>那些搞晕你的单位：DPI / PPI / DP / PX<br> APP 中尺寸单位和各自的意思</p><table><thead><tr><th>尺寸单位</th><th align="left">代表的意思</th></tr></thead><tbody><tr><td>px: pixel</td><td align="left">【像素】  电子屏幕上组成一幅图画或照片的最基本单元</td></tr><tr><td>pt: ponit</td><td align="left">【点】印刷行业常用单位，等于1/72英寸</td></tr><tr><td>ppi: pixel per inch</td><td align="left">【每英寸像素数】  该值越高，则屏幕越细腻</td></tr><tr><td>dpi: dot per inch</td><td align="left">【每英寸像素数】  该值越高，则屏幕越细腻</td></tr><tr><td>dp/dip:Density-independent pixel</td><td align="left">安卓开发用的长度单位，1dp表示在屏幕像素点密度为160ppi时1px长度</td></tr><tr><td>sp: scale-independent pixel</td><td align="left">安卓开发用的字体大小单位</td></tr></tbody></table><p> <strong>相互关系</strong></p><ul><li><p>pt 和 px</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>pt = (DPI / <span class="number">72</span>)px</span><br></pre></td></tr></table></figure><p> 当在 ps 中新建画布的分辨率为 72ppi(即72dpi),1pt = 1px</p></li><li><p>PPI 和 DPI<br> DPI 最初适用于衡量打印物上每英寸的点数密度。DPI 值越小图片越不精细。当 DPI 的概念用在计算机屏幕上时，就称为了 PPI。同理：PPI 就是计算机屏幕上每英寸可以显示的像素点的数量。因此，在电子屏幕中提到的 PPI 和 DPI 是一致的。</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">可认为 DPI = PPI</span><br></pre></td></tr></table></figure></li><li><p>PPI 的计算方法<br>  <img src="http://upload-images.jianshu.io/upload_images/3303429-c7a1c80febcc85a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ppi 的计算方法">    </p></li><li><p>px 和 dp<br>dp为安卓开发时的长度单位，根据不同的屏幕分辨率，与px有不同的对应关系。<br>dp的大小的定义为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>dp=（屏幕 ppi / <span class="number">160</span>）px</span><br></pre></td></tr></table></figure><p><img src="https://github.com/xxtlant/BlogPicture/blob/master/android%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/dpi%E4%B8%8E%E5%AF%86%E5%BA%A6%E7%9A%84%E6%8D%A2%E7%AE%97.png?raw=true" alt="DPI 与 PPI"></p></li><li><p>dp 和 sp<br>dp和sp类似，都会随着屏幕大小和分辨率变化而改变，不同的是，在android中，dp表示长度单位，sp表示字体大小，在多数情况下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>dp=<span class="number">1</span>sp</span><br></pre></td></tr></table></figure><p>但是在文字尺寸是“大”或“超大”时，1sp &gt; 1dp。</p><!--more--></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 实战技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Studio 常用插件整理</title>
      <link href="/posts/AS_plug.html"/>
      <url>/posts/AS_plug.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>最近改用 Android Studio 3.0 preview ,顺便整理一下，常用的插件。</p><h4 id="GsonFormat"><a href="#GsonFormat" class="headerlink" title="GsonFormat"></a><span style="font-size: 12pt;"><a href="https://plugins.jetbrains.com/plugin/7654-gsonformat" target="_blank" rel="noopener">GsonFormat</a></span></h4><p> 将 Json 字符串快速转成 JavaBean 对象，免去我们根据 Json 字符串手写对应 Java Bean 的过程.</p><p><img src="https://plugins.jetbrains.com/files/7654/screenshot_15729.png" alt="gsonFormat"><br>Tips: 可以使用快捷键 alt + s (windows)  / option + s (mac) </p><a id="more"></a><h4 id="Android-ButterKnife-Zelezny"><a href="#Android-ButterKnife-Zelezny" class="headerlink" title="Android ButterKnife Zelezny"></a><span style="font-size: 12pt;"><a href="https://plugins.jetbrains.com/plugin/7369-android-butterknife-zelezny" target="_blank" rel="noopener">Android ButterKnife Zelezny</a></span></h4><p>配合 <a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="noopener">butterknife</a> 实现注解，不用再手动实现 findViewById 了。</p><p><img src="https://plugins.jetbrains.com/files/7369/screenshot_14384.png" alt="Android ButterKnife Zelezny"></p><h4 id="Android-Methods-Count"><a href="#Android-Methods-Count" class="headerlink" title="Android Methods Count"></a><span style="font-size: 12pt;"><a href="https://plugins.jetbrains.com/plugin/8076-android-methods-count" target="_blank" rel="noopener">Android Methods Count</a></span></h4><p> 显示依赖库中得方法数<br><img src="https://plugins.jetbrains.com/files/8076/screenshot_15509.png" alt="Android Methods Count"></p><h4 id="Lifecycle-Sorter"><a href="#Lifecycle-Sorter" class="headerlink" title="Lifecycle Sorter"></a><span style="font-size: 12pt;"><a href="https://plugins.jetbrains.com/plugin/7742-lifecycle-sorter" target="_blank" rel="noopener">Lifecycle Sorter</a></h4><p> 可以根据Activity或者fragment的生命周期对其生命周期方法位置进行先后排序， windows 快捷键Ctrl + alt + K . Mac 快捷键 option + command + K.<br><img src="https://plugins.jetbrains.com/files/7742/screenshot_15070.png" alt="Lifecycle Sorter"></p><h4 id="Android-Code-Generator"><a href="#Android-Code-Generator" class="headerlink" title="Android Code Generator"></a><span style="font-size: 12pt;"><a href="https://plugins.jetbrains.com/plugin/7595-android-code-generator" target="_blank" rel="noopener">Android Code Generator</a></span></h4><p> 根据布局文件快速生成对应的Activity，Fragment，Adapter，Menu。<br><img src="https://plugins.jetbrains.com/files/7595/screenshot_14834.png" alt="Android Code Generator"></p><h4 id="Android-Parcelable-code-generator"><a href="#Android-Parcelable-code-generator" class="headerlink" title="Android Parcelable code generator"></a><span style="font-size: 12pt;"><a href="https://plugins.jetbrains.com/plugin/7332-android-parcelable-code-generator" target="_blank" rel="noopener">Android Parcelable code generator</a></span></h4><p> JavaBean 序列化，快速实现 Parcelable 接口。<br><img src="https://segmentfault.com/image?src=http://img.blog.csdn.net/20160416104459926&objectId=1190000005092842&token=ab29ed79d41be9e42b3a3d2ed1ec3bef" alt="Android Parcelable code generator"></p><h4 id="CodeGlance"><a href="#CodeGlance" class="headerlink" title="CodeGlance"></a><span style="font-size: 12pt;"><a href="https://plugins.jetbrains.com/plugin/7275-codeglance" target="_blank" rel="noopener">CodeGlance</a></span></h4><p> 在右边实现代码预览，类似于 sublime ，快速定位。<br><img src="https://plugins.jetbrains.com/files/7275/screenshot_16821.png" alt="CodeGlance"></p><h4 id="FindBugs-IDEA"><a href="#FindBugs-IDEA" class="headerlink" title="FindBugs-IDEA"></a><span style="font-size: 12pt;"><a href="https://plugins.jetbrains.com/plugin/3847-findbugs-idea" target="_blank" rel="noopener">FindBugs-IDEA</a></span></h4><p> 查找 bug 的插件。具体使用可见 freddyyao 的简书文章 -&gt; <a href="http://www.jianshu.com/p/bc27857c89e4" target="_blank" rel="noopener">代码缺陷扫描神器——FindBugs</a><br><img src="https://plugins.jetbrains.com/files/3847/screenshot_2542.png" alt="FindBugs-IDEA"></p><h4 id="ADB-WIFI"><a href="#ADB-WIFI" class="headerlink" title="ADB WIFI"></a><span style="font-size: 12pt;"><a href="https://plugins.jetbrains.com/plugin/7856-adb-wifi" target="_blank" rel="noopener">ADB WIFI</a></span></h4><p> 使用wifi无线调试你的app，无需root权限<br><img src="https://plugins.jetbrains.com/files/7856/screenshot_15153.png" alt="ADB WIFI"></p><h4 id="JSONOnlineViewer"><a href="#JSONOnlineViewer" class="headerlink" title="JSONOnlineViewer"></a><span style="font-size: 12pt;"><a href="https://plugins.jetbrains.com/plugin/7838-jsononlineviewer" target="_blank" rel="noopener">JSONOnlineViewer</a></span></h4><p> 在 Android Studio 中，请求、调试接口<br><img src="https://plugins.jetbrains.com/files/7838/screenshot_15113.png" alt="JSONOnlineViewer"></p><h4 id="Android-Styler"><a href="#Android-Styler" class="headerlink" title="Android Styler"></a><span style="font-size: 12pt;"><a href="https://plugins.jetbrains.com/plugin/7972-android-styler" target="_blank" rel="noopener">Android Styler</a></span></h4><p> 根据 xml 自动生成 style 代码的插件。 需要把要生成 style 的代码 copy 到 styles.xml 中，选中进行设置。<br><img src="https://plugins.jetbrains.com/files/7972/screenshot_15340.png" alt=""><br><img src="https://plugins.jetbrains.com/files/7972/screenshot_15339.png" alt=""><br><img src="https://plugins.jetbrains.com/files/7972/screenshot_15338.png" alt="Android Styler"></p><h4 id="Android-Drawable-Importer"><a href="#Android-Drawable-Importer" class="headerlink" title="Android Drawable Importer"></a><span style="font-size: 12pt;"><a href="https://plugins.jetbrains.com/plugin/7658-android-drawable-importer" target="_blank" rel="noopener">Android Drawable Importer</a></span></h4><p> 这是一个非常强大的图片导入插件。它导入Android图标与Material图标的Drawable ，批量导入Drawable ，多源导入Drawable（即导入某张图片各种dpi对应的图片）<br><img src="https://plugins.jetbrains.com/files/7658/screenshot_15533.png" alt=""><br><img src="https://plugins.jetbrains.com/files/7658/screenshot_15532.png" alt=""><br><img src="https://plugins.jetbrains.com/files/7658/screenshot_15534.png" alt=""><br><img src="https://plugins.jetbrains.com/files/7658/screenshot_15536.png" alt=""><br><img src="https://plugins.jetbrains.com/files/7658/screenshot_15351.png" alt="Android Drawable Importer"></p><h4 id="Genymotion"><a href="#Genymotion" class="headerlink" title="Genymotion"></a><span style="font-size: 12pt;"><a href="https://plugins.jetbrains.com/plugin/7269-genymotion" target="_blank" rel="noopener">Genymotion</a></span></h4><p> 一款速度较快的 Android 模拟器，可以在 Android Studio 中直接开启。<br><img src="https://plugins.jetbrains.com/files/7269/screenshot_14278.png" alt="Genymotion"></p><h4 id="SQLScout"><a href="#SQLScout" class="headerlink" title="SQLScout"></a><span style="font-size: 12pt;"><a href="https://plugins.jetbrains.com/plugin/8322-sqlscout-sqlite-support-" target="_blank" rel="noopener">SQLScout</a></span></h4><p> 在 Android Studio 中调试数据库 (SQLite)</p><p>详细使用参考：<a href="https://juejin.im/post/58e0d781a0bb9f0069ec08d3" target="_blank" rel="noopener">在 Android Studio 上调试数据库 ( SQLite )</a><br><img src="https://plugins.jetbrains.com/files/8322/screenshot_15823.png" alt="SQLScout"></p><h4 id="GradleDependenciesHelperPlugin"><a href="#GradleDependenciesHelperPlugin" class="headerlink" title="GradleDependenciesHelperPlugin"></a><span style="font-size: 12pt;"><a href="https://github.com/ligi/GradleDependenciesHelperPlugin" target="_blank" rel="noopener">GradleDependenciesHelperPlugin</a></span></h4><p> maven gradle 依赖支持自动补全<br><img src="http://upload-images.jianshu.io/upload_images/3303429-15b6eed60db1bbde?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="GradleDependenciesHelperPlugin"></p><h4 id="RemoveButterKnife"><a href="#RemoveButterKnife" class="headerlink" title="RemoveButterKnife"></a><span style="font-size: 12pt;"><a href="https://github.com/u3shadow/RemoveButterKnife" target="_blank" rel="noopener">RemoveButterKnife</a></span></h4><p> ButterKnife这个第三方库每次更新之后，绑定view的注解都会改变，从bind,到inject，再到bindview，搞得很多人都不敢升级，一旦升级，就会有巨量的代码需要手动修改，非常痛苦当我们有一些非常棒的代码需要拿到其他项目使用，但是我们发现，那个项目对第三方库的使用是有限制的，我们不能使用butterknife，这时候，我们又得从注解改回findviewbyid针对上面的两种情况，如果view比较少还好说，如果有几十个view，那么我们一个个的手动删除注解，写findviewbyid语句，简直是一场噩梦（别问我为什么知道这是噩梦）所以，这种有规律又重复简单的工作为什么不能用一个插件来实现呢？于是RemoveButterKnife的想法就出现了。<br><a href="http://www.u3coding.com/2016/06/24/androidstudio-plugin-removebutterknife-di/" target="_blank" rel="noopener">具体介绍</a></p><p><img src="http://upload-images.jianshu.io/upload_images/3303429-43ff9b5a2e3a1405?imageMogr2/auto-orient/strip" alt="RemoveButterKnife"></p><h4 id="AndroidProguardPlugin"><a href="#AndroidProguardPlugin" class="headerlink" title="AndroidProguardPlugin"></a><span style="font-size: 12pt;"><a href="https://github.com/zhonghanwen/AndroidProguardPlugin" target="_blank" rel="noopener">AndroidProguardPlugin</a></span></h4><p> 一键生成项目混淆代码插件，值得你安装~<br><img src="https://camo.githubusercontent.com/adef227c0dc014f53b6e2a46977ef9ff2ceeb5a4/687474703a2f2f3778726e6b6f2e636f6d312e7a302e676c622e636c6f7564646e2e636f6d2f616e64726f696470726f6775617264312e676966" alt="AndroidProguardPlugin"></p><h4 id="EventBus3-Intellij-Plugin"><a href="#EventBus3-Intellij-Plugin" class="headerlink" title="EventBus3 Intellij Plugin"></a><span style="font-size: 12pt;"><a href="https://plugins.jetbrains.com/plugin/8603-eventbus3-intellij-plugin" target="_blank" rel="noopener">EventBus3 Intellij Plugin</a></span></h4><p> 为 EventBus 提供快速索引和跳转（目前只支持 EventBus 3.x 版本）<br>从 EventBus.post 到 @Subscribe 或者 onEventMainThread<br>从 @Subscribe 到 EventBus.post</p><p><img src="https://plugins.jetbrains.com/files/8603/screenshot_16147.png" alt="EventBus3 Intellij Plugin"></p><h4 id="Android-Studio-Prettify"><a href="#Android-Studio-Prettify" class="headerlink" title="Android Studio Prettify"></a><span style="font-size: 12pt;"><a href="https://plugins.jetbrains.com/plugin/7405" target="_blank" rel="noopener">Android Studio Prettify</a></span></h4><p> 可以将代码中的字符串写在string.xml文件中<br>选中字符串鼠标右键选择图中所示<br><img src="https://plugins.jetbrains.com/files/7405/screenshot_14418.png" alt="Android Studio Prettify"></p><h4 id="ignore"><a href="#ignore" class="headerlink" title=".ignore"></a><span style="font-size: 12pt;"><a href="https://plugins.jetbrains.com/plugin/7495--ignore" target="_blank" rel="noopener">.ignore</a></span></h4><p> 在Git 中想要过滤掉一些不想提交的文件，可以把相应的文件添加到.gitignore 中，而.gitignore 这个Android Studio 插件根据不同的语言来选择模板，就不用自己在费事添加一些文件了，而且还有自动补全功能，过滤文件再也不要复制文件名了。<br>我们做项目的时候，并不是所有文件都是要提交的，比如构建的build 文件夹，本地配置文件，每个Module 生成的iml 文件，但是我们每次add，commit 都会不小心把它们添加上去，而gitignore 就是解决这种痛点的，如果你不想提交的文件，就可以在创建项目的时候将这个文件中添加即可，将一些通用的东西屏蔽掉。</p><p><img src="https://plugins.jetbrains.com/files/7495/screenshot_14959.png" alt=".ignore"></p><h4 id="Markdown-Navigator"><a href="#Markdown-Navigator" class="headerlink" title="Markdown Navigator"></a><span style="font-size: 12pt;"><a href="https://plugins.jetbrains.com/plugin/7896-markdown-navigator" target="_blank" rel="noopener">Markdown Navigator</a></span></h4><p> markdown插件</p><p><img src="https://plugins.jetbrains.com/files/7896/screenshot_15818.png" alt="Markdown Navigator"></p><h4 id="ECTranslation"><a href="#ECTranslation" class="headerlink" title="ECTranslation"></a><span style="font-size: 12pt;"><a href="https://plugins.jetbrains.com/plugin/8469-ectranslation" target="_blank" rel="noopener">ECTranslation</a></span></h4><p> Android Studio 翻译插件,可以将英文翻译为中文.</p><p><img src="https://github.com/Skykai521/ECTranslation/raw/master/img/translation_img.png" alt="ECTranslation"></p><h4 id="Codota"><a href="#Codota" class="headerlink" title="Codota"></a><span style="font-size: 12pt;"><a href="http://www.codota.com/" target="_blank" rel="noopener">Codota</a></span></h4><p> 搜索最好的Android代码.</p><h4 id="Exynap"><a href="#Exynap" class="headerlink" title="Exynap"></a><span style="font-size: 12pt;"><a href="https://plugins.jetbrains.com/plugin/8600-exynap" target="_blank" rel="noopener">Exynap</a></span></h4><p> Exynap 一个帮助开发者自动生成样板代码的 AndroidStudio 插件<br><img src="https://plugins.jetbrains.com/files/8600/screenshot_16141.png" alt="Exynap"></p><h4 id="MVPHelper"><a href="#MVPHelper" class="headerlink" title="MVPHelper"></a><span style="font-size: 12pt;"><a href="https://plugins.jetbrains.com/plugin/8507-mvphelper" target="_blank" rel="noopener">MVPHelper</a></span></h4><p> 一款Intellj IDEA 和Android Studio的插件，可以为MVP生成接口以及实现类，解放双手。<br>具体请查看<a href="http://androidwing.net/index.php/27" target="_blank" rel="noopener">Android Studio插件之MVPHelper，一键生成MVP代码</a>一文<br><img src="https://github.com/githubwing/MVPHelper/raw/master/img/mvp_presenter.gif" alt="MVPHelper"></p><h4 id="ADB-Idea"><a href="#ADB-Idea" class="headerlink" title="ADB Idea"></a><span style="font-size: 12pt;"><a href="https://plugins.jetbrains.com/plugin/7380-adb-idea" target="_blank" rel="noopener">ADB Idea</a></span></h4><p> 一键清理缓存、卸载，重启 APP</p><p><img src="http://upload-images.jianshu.io/upload_images/3303429-2989b94e026cc0cd.gif?imageMogr2/auto-orient/strip" alt="adb-idea.gif"></p><!--more-->]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Android Studio </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
